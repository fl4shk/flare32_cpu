\documentclass{article}

\usepackage{graphicx}
\usepackage{float}
\usepackage{fancyvrb}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{setspace}
\usepackage[nottoc]{tocbibind}
\usepackage[font=large]{caption}
\usepackage{framed}
\usepackage{tabularx}
\usepackage{amsmath}
%\usepackage{hyperref}
\usepackage[backend=biber,sorting=none]{biblatex}
%\usepackage[
%	backend=biber,
%	style=ieee,
%	sorting=none
%]{biblatex}
%\addbibresource{project_refs.bib}


\title{Flare32 CPU}
%\date{2018-11-2}
\author{FL4SHK}

%% Hide section, subsection, and subsubsection numbering
%\renewcommand{\thesection}{}
%\renewcommand{\thesubsection}{}
%\renewcommand{\thesubsubsection}{}


% Alternative form of doing section stuff
\renewcommand{\thesection}{}
\renewcommand{\thesubsection}{\arabic{section}.\arabic{subsection}}
\makeatletter
\def\@seccntformat#1{\csname #1ignore\expandafter\endcsname\csname the#1\endcsname\quad}
\let\sectionignore\@gobbletwo
\let\latex@numberline\numberline
\def\numberline#1{\if\relax#1\relax\else\latex@numberline{#1}\fi}
\makeatother

\makeatletter
\renewcommand\tableofcontents{%
    \@starttoc{toc}%
}
\makeatother

%Figures
%\begin{figure}[H]
%	\includegraphics[width=\linewidth]{example.png}
%\end{figure}

% Verbatim text
%\VerbatimInput{main.cpp}

%% Fixed-width text
%\texttt{module FullAdder(input logic a, b, c_in, output logic s, c_out);}
%% Bold
%\textbf{green eggs}
%% Italic
%\textit{and}
%% Underline
%\underline{eggs}

%% Non-numbered list
%\begin{itemize}
%\item item 0
%\item item 1
%\end{itemize}

%% Numbered list
%\begin{enumerate}
%\item item 0
%\item item 1
%\end{enumerate}

%% Spaces and new lines
%LaTeX ignores extra spaces and new lines.
%Place \\ at the end of a line to create a new line (but not create a new
%paragraph)

%% Use "\noindent" to prevent a paragraph from indenting

%% Tables
%\begin{table}[H]
%	\begin{center}
%		\caption{Results for \texttt{blocksPerGrid = 5}}:
%		\label{tab:table0}
%		\begin{tabular}{c|c}
%			\textbf{\texttt{threadsPerBlock}}
%				& \textbf{\texttt{scaling()} Running Time (us)}\\
%			\hline
%			32 & 156.39\\
%			64 & 163.59\\
%			128 & 155.62\\
%			256 & 155.56\\
%			512 & 161.57\\
%			1024 & 166.85\\
%		\end{tabular}
%	\end{center}
%\end{table}

\begin{document}
	\maketitle
	\pagenumbering{gobble}
	\newpage
	\pagenumbering{arabic}


	%\doublespacing
	%\section{Abstract}
	%\setcounter{section}{-1}
	%%This is an instruction set designed to be similar to the SuperFX/GSU,
	%%while not being binary compatible, nor even assembly language
	%%compatible. It takes some of the ideas from the GSU and runs with
	%%them.
	%This is an instruction set that is basically just my answer to THUMB
	%(especially original THUMB), with some ideas taken from other places as
	%well. This shows how to get more out of 16-bit instructions than THUMB
	%allows.

	\newpage
	\singlespacing
	\section{Table of Contents}
	\tableofcontents
	\newpage

	\section{Introduction}

	\subsection{General Information}
		\begin{itemize}
		%--------
		\item Addresses are 32-bit.
		\item Big-endian byte ordering is used. 
		\item Bytes are octets (8 bits).
		\item Instructions must be aligned to 16 bits, so jump and
			branch targets must also be aligned to 16 bits.
			\begin{itemize}
			%--------
			\item Branch offsets encoded into instructions must be
				16-bit aligned, or in other words bit 0 of the branch
				offset must be \texttt{0b0}
			%--------
			\end{itemize}
		%--------
		\end{itemize}

	\subsection{Registers}

	\doublespacing
	There are sixteen general-purpose registers (all of which are 32-bit):
	\texttt{r0}, \texttt{r1},
	\texttt{r2}, \texttt{...}, \texttt{r11}, \texttt{r12},
	\texttt{lr} (link register, the return address of \texttt{bl} and
		\texttt{jl}),
	\texttt{fp} (frame pointer), \texttt{sp} (stack pointer).

	The program counter, \texttt{pc}, is 32 bits long, as addresses are
	32-bit.

	Here are the special-purpose registers:
	\singlespacing
	\begin{itemize}
	%--------
	\item \texttt{flags}: arithmetic/logic FLAGS;
		(reg encoding: \texttt{0x0})
	%\item \texttt{hi}:
	%	HIgh 32 bits of instructions that produce 64-bit results;
	%	(reg encoding: \texttt{0x1})
	%\item \texttt{lo}:
	%	LOw 32 bits of instructions that produce 64-bit results;
	%	(reg encoding: \texttt{0x2})
	\item \texttt{ids}: Interrupt DeStination:
		the address to jump to upon an interrupt being serviced
			(also known as the interrupt vector);
		%(reg encoding: \texttt{0x3})
		(reg encoding: \texttt{0x1})
	\item \texttt{ira}: Interrupt Return Address:
		the address that was jumped from upon an interrupt being
			serviced;
		%(reg encoding: \texttt(0x4))
		(reg encoding: \texttt(0x2))
	\item \texttt{ie}: IRQ Enable flag:
		flag indicating whether IRQs are
			disabled (\texttt{0x0}) or enabled (\texttt{0x1});
		note that this flag starts with a value of \texttt{0x0};
		%(reg encoding: \texttt{0x5})
		(reg encoding: \texttt{0x3})
	\item \texttt{ity}: Interrupt TYpe:
		flag indicating whether the most recently taken interrupt is an
			IRQ (\texttt{0x0}) or a \texttt{swi} (\texttt{0x1})
		%(reg encoding: \texttt{0x6})
		(reg encoding: \texttt{0x4})
	\item \texttt{sty}: Software interrupt TYpe:
		\texttt{swi}'s argument. For \texttt{swi rA, \#simm}, this is the
			value \texttt{rA + simm}
		%(reg encoding: \texttt{0x7})
		(reg encoding: \texttt{0x5})
	\item Note:
		All other encodings for special-purpose registers are reserved.
	%--------
	\end{itemize}
	\doublespacing
	Here are the bits of \texttt{flags}:
	\singlespacing
	\begin{itemize}
	%--------
	\item Zero (Z): (\texttt{flags} bit 0)
	\item Carry (C): (\texttt{flags} bit 1)
	\item oVerflow (V): (\texttt{flags} bit 2)
	\item Negative (N): (\texttt{flags} bit 3)
	\item Note:
		All other bit positions of \texttt{flags} are reserved.
	%--------
	\end{itemize}

	%\begin{table}[H]
	%	\begin{center}
	%		\caption{The Flags}
	%		\label{tab:flags}
	%		\begin{tabular}{|c|c|c|c|}
	%			\hline
	%			Zero (Z) & Carry (C) & oVerflow (V) & Negative (N)\\
	%			\hline
	%		\end{tabular}
	%	\end{center}
	%\end{table}

	\newpage
	\section{Instruction Set}
	%While this machine takes inspiration from the GSU, it uses 16-bit
	%instructions rather than 8-bit ones.

	\subsection{Instruction Group 0: \texttt{pre} and \texttt{lpre}}
	For \texttt{pre}, the following encoding is used, with each character
	representing one bit: \\
	\texttt{0000 iiii iiii iiii}, where 
	
	\singlespacing
	\begin{itemize}
	%--------
	\item \texttt{i} is a 12-bit constant.
	%--------
	\end{itemize}

	For \texttt{lpre}, the following encoding is used, with each character
	representing one bit: \\
	\texttt{0001 0iii iiii iiii  iiii iiii iiii iiii}, where

	\singlespacing
	\begin{itemize}
	%--------
	\item \texttt{i} is a 27-bit constant.
	%--------
	\end{itemize}

	\texttt{pre} and \texttt{lpre} are mechanisms by which immediates
	larger than normal can be used, essentially acting like variable width
	instructions.

	There is no mechanism in the assembly language itself to use
	\texttt{pre} or \texttt{lpre} as instructions. Instead, it is expected
	that the assembler or linker will be the one to insert \texttt{pre} or
	\texttt{lpre} as needed if an immediate is too large for a particular
	instruction.

	For non-branch instructions:
	\begin{itemize}
	%--------
	\item If \texttt{pre} is used, the immediate field of the
	\texttt{pre} instruction will form bits \texttt{[16:5]} of the
	immediate of the next non-\texttt{index} instruction. The 17-bit
	immediate will then be sign-extended to 32 bits.

	\item On the other hand, if \texttt{lpre} is used, the immediate
	field of the \texttt{lpre} instruction will form bits
	\texttt{[31:5]} of the immediate of the next non-\texttt{index}
	instruction.
	%--------
	\end{itemize}


	For branch instructions (group 3):
	\begin{itemize}
	%--------
	\item if \texttt{pre} is used, the
	immediate field of the \texttt{pre} instruction will form bits
	\texttt{[20:9]} of the immediate of the next non-\texttt{index}
	instruction. The 21-bit immediate will then be sign-extended to 32
	bits.

	\item On the other hand, if \texttt{lpre} is used, the immediate
	field of the \texttt{lpre} instruction will form bits
	\texttt{[31:9]} of the immediate of the next non-\texttt{index}
	instruction.
	%--------
	\end{itemize}

	Instructions that use an immediate value, other than \texttt{pre},
	\texttt{lpre}, and relative branches normally have 5-bit immediates.
	Relative branches normally have 9-bit branch offsets. if \texttt{pre}
	or \texttt{lpre} is used with a relative branch, bits \texttt{[9:5]} of
	the branch offset that is encoded directly into a relative branch
	instruction will be ignored, and the immediate field of the
	\texttt{pre} or \texttt{lpre} instruction will be used to determine
	bits \texttt{[9:5]} of the branch offset..

	\subsubsection{Handling of \texttt{pre}, \texttt{lpre}, and
	\texttt{index}}

	When a \texttt{pre} or \texttt{lpre} instruction is found, \texttt{pre}
	or \texttt{lpre} will be considered to be "in effect". This condition
	lasts for one or two instructions after the \texttt{pre} or
	\texttt{lpre} instruction, depending on whether or not \texttt{index}
	was in effect.

	\texttt{index} is an instruction (defined later) that allows a
	subsequent load or store instruction to perform \texttt{base\_reg +
	index\_reg} indexing. When an \texttt{index} instruction is found, it
	is considered to be in effect. Like \texttt{pre} and \texttt{lpre},
	\texttt{index} is inserted automatically by the assembler.

	\texttt{index} can be combined with \texttt{pre} or \texttt{lpre}, and
	it does not matter whether \texttt{index} or the
	\texttt{pre}/\texttt{lpre} instruction came first.

	%\texttt{pre} and \texttt{lpre} cannot both be combined in the same
	%instruction. If this is attempted, the hardware will treat the
	%instruction as a NOP, and \texttt{pre}, \texttt{lpre}, and
	%\texttt{index} will all stop being in effect.

	%Two \texttt{pre} or \texttt{lpre} instructions also cannot both be
	%combined. If this is attempted, the hardware will treat the
	%instruction as a NOP, and \texttt{pre}, \texttt{lpre}, and
	%\texttt{index} will all stop being in effect.

	When \texttt{pre}, \texttt{lpre}, or \texttt{index} is in effect,
	IRQs will not be serviced.

	Pseudo code for handling the how \texttt{pre}, \texttt{lpre}, and
	\texttt{index} are to be handled regarding whether or not they are "in
	effect" is as follows:

	\VerbatimInput{verbatim_input/pre_lpre_index.txt}



	\subsection{Instruction Group 1}
	The following encoding is used, with each character representing one
	bit: \\
	\texttt{001i iiii oooo aaaa}, where

	\singlespacing
	\begin{itemize}
	%--------
	\item \texttt{i} is a 5-bit sign-extended immediate, and is denoted
	\texttt{simm}
	\item \texttt{a} encodes register \texttt{rA}
	\item \texttt{o} is the opcode
	%\item \texttt{f} is \texttt{0} if this instruction cannot affect
	%flags and \texttt{1} if this instruction is permitted to affect
	%flags. 
	%--------
	\end{itemize}
	\doublespacing

	Here is a list of instructions from this encoding group.

	\singlespacing
	\begin{itemize}
	%--------
	\item Opcode \texttt{0x0}:
		\texttt{\textbf{add} rA, \#simm}
	\item Opcode \texttt{0x1}:
		% subi was deemed (mostly) unnecessary given that immediates are
		% sign-extended.
		\texttt{\textbf{add} rA, pc, \#simm}
		\begin{itemize}
		%--------
		\item Effect:
			\texttt{rA <= pc + simm + 2;}
		%--------
		\end{itemize}
	\item Opcode \texttt{0x2}:
		\texttt{\textbf{add} rA, sp, \#simm}
	\item Opcode \texttt{0x3}:
		\texttt{\textbf{add} rA, fp, \#simm}
	\item Opcode \texttt{0x4}:
		\texttt{\textbf{cmp} rA, \#simm}
		\begin{itemize}
		%--------
		\item Effect: Compare \texttt{rA} to \texttt{simm}.
		\item Affectable flags:
			\texttt{Z}, \texttt{C}, \texttt{V}, \texttt{N}
		%--------
		\end{itemize}
	\item Opcode \texttt{0x5}:
		\texttt{\textbf{cpy} rA, \#simm}
		\begin{itemize}
		%--------
		\item Effect: Copy an immediate value into \texttt{rA}
		%--------
		\end{itemize}
	\item Opcode \texttt{0x6}:
		\texttt{\textbf{lsl} rA, \#simm}
		\begin{itemize}
		%--------
		\item Effect: Logical shift left
		%--------
		\end{itemize}
	\item Opcode \texttt{0x7}:
		\texttt{\textbf{lsr} rA, \#simm}
		\begin{itemize}
		%--------
		\item Effect: Logical shift right
		%--------
		\end{itemize}
	\item Opcode \texttt{0x8}:
		\texttt{\textbf{asr} rA, \#simm}
		\begin{itemize}
		%--------
		\item Effect: Arithmetic shift right
		%--------
		\end{itemize}
	\item Opcode \texttt{0x9}:
		\texttt{\textbf{and} rA, \#simm}
		\begin{itemize}
		%--------
		\item Effect: Bitwise AND
		%--------
		\end{itemize}
	\item Opcode \texttt{0xa}:
		\texttt{\textbf{orr} rA, \#simm}
		\begin{itemize}
		%--------
		\item Effect: Bitwise OR
		%--------
		\end{itemize}
	\item Opcode \texttt{0xb}:
		\texttt{\textbf{xor} rA, \#simm}
		\begin{itemize}
		%--------
		\item Effect: Bitwise XOR
		%--------
		\end{itemize}
	\item Opcode \texttt{0xc}:
		\texttt{\textbf{ze} rA, \#simm}
		\begin{itemize}
		%--------
		%\item Effect: Set \texttt{rA[31:8]} to zero.
		\item Effect: Set \texttt{rA[31:simm]} to zero.
		%--------
		\end{itemize}
	\item Opcode \texttt{0xd}:
		\texttt{\textbf{se} rA, \#simm}
		\begin{itemize}
		%--------
		%\item Effect: Set \texttt{rA[31:16]} to zero.
		\item Effect:
			Sign-extend \texttt{rA[simm:0]} to 32 bits, then copy that
			value to \texttt{rA}.
		%--------
		\end{itemize}
	\item Opcode \texttt{0xe}:
		\texttt{\textbf{swi} rA, \#simm}
		\begin{itemize}
		%--------
		\item Effect:
			Call software interrupt number \texttt{rA + simm}.
		%--------
		\end{itemize}
	\item Opcode \texttt{0xf}:
		\texttt{\textbf{swi} \#simm}
		\begin{itemize}
		%--------
		\item Effect:
			Call software interrupt number \texttt{simm}.
		%--------
		\end{itemize}
	%\item Opcode \texttt{0xe}:
	%	\texttt{\textbf{seb} rA}
	%	\begin{itemize}
	%	%--------
	%	\item Effect:
	%		Sign-extend \texttt{rA[7:0]} to 32 bits, then copy that
	%		value to \texttt{rA}
	%	%--------
	%	\end{itemize}
	%\item Opcode \texttt{0xf}:
	%	\texttt{\textbf{seh} rA}
	%	\begin{itemize}
	%	%--------
	%	\item Effect:
	%		Sign-extend \texttt{rA[15:0]} to 32 bits, then copy that
	%		value to \texttt{rA}
	%	%--------
	%	\end{itemize}
	\end{itemize}

	\doublespacing

	\subsection{Instruction Group 2}
	The following encoding is used, with each character representing one
	bit: \\
	\texttt{010f oooo bbbb aaaa}, where

	\singlespacing
	\begin{itemize}
	%--------
	\item \texttt{o} is the opcode
	\item \texttt{b} encodes register \texttt{rB}
	\item \texttt{a} encodes register \texttt{rA}
	\item \texttt{f} is encoded as \texttt{0} if this instruction
	cannot affect flags and encoded \texttt{1} if this instruction is
	permitted to affect flags. Note that \texttt{cmp} is permitted to
	affect flags regardless of this bit.
	%--------
	\end{itemize}
	\doublespacing

	Here is a list of instructions from this encoding group.

	\singlespacing
	\begin{itemize}
	%--------
	\item Opcode \texttt{0x0}:
		\texttt{\textbf{add} rA, rB}
		\begin{itemize}
		%--------
		\item Mnemonic for when flags not affected: \texttt{add}
		\item Mnemonic for when flags affected: \texttt{add.f}
		\item Affectable flags:
			\texttt{Z}, \texttt{C}, \texttt{V}, \texttt{N}
		%--------
		\end{itemize}
	\item Opcode \texttt{0x1}:
		\texttt{\textbf{sub} rA, rB}
		\begin{itemize}
		%--------
		\item Mnemonic for when flags not affected: \texttt{sub}
		\item Mnemonic for when flags affected: \texttt{sub.f}
		\item Affectable flags:
			\texttt{Z}, \texttt{C}, \texttt{V}, \texttt{N}
		%--------
		\end{itemize}
	\item Opcode \texttt{0x2}:
		\texttt{\textbf{add} rA, sp, rB}
		\begin{itemize}
		%--------
		\item Mnemonic for when flags not affected: \texttt{add}
		\item Mnemonic for when flags affected: \texttt{add.f}
		\item Affectable flags:
			\texttt{Z}, \texttt{C}, \texttt{V}, \texttt{N}
		%--------
		\end{itemize}
	\item Opcode \texttt{0x3}
		\texttt{\textbf{add} rA, fp, rB}
		\begin{itemize}
		%--------
		\item Mnemonic for when flags not affected: \texttt{add}
		\item Mnemonic for when flags affected: \texttt{add.f}
		\item Affectable flags:
			\texttt{Z}, \texttt{C}, \texttt{V}, \texttt{N}
		%--------
		\end{itemize}
	\item Opcode \texttt{0x4}:
		\texttt{\textbf{cmp} rA, rB}
		\begin{itemize}
		%--------
		\item Effect: Compare \texttt{rA} to \texttt{rB}. \texttt{cmp}
			is \textit{always} able to affect flags, independent of the
			encoded \texttt{f} bit of the instruction.
		\item Affectable flags:
			\texttt{Z}, \texttt{C}, \texttt{V}, \texttt{N}
		%--------
		\end{itemize}
	\item Opcode \texttt{0x5}:
		\texttt{\textbf{cpy} rA, rB}
		\begin{itemize}
		%--------
		\item Mnemonic for when flags not affected: \texttt{cpy}
		\item Mnemonic for when flags affected: \texttt{cpy.f}
		\item Effect: Copy \texttt{rB} into \texttt{rA}
		\item Affectable flags:
			\texttt{Z}, \texttt{N}
		%--------
		\end{itemize}
	\item Opcode \texttt{0x6}:
		\texttt{\textbf{lsl} rA, rB}
		\begin{itemize}
		%--------
		\item Mnemonic for when flags not affected: \texttt{lsl}
		\item Mnemonic for when flags affected: \texttt{lsl.f}
		\item Effect: Logical shift left
		\item Affectable flags:
			\texttt{Z}, \texttt{N}
		%--------
		\end{itemize}
	\item Opcode \texttt{0x7}:
		\texttt{\textbf{lsr} rA, rB}
		\begin{itemize}
		%--------
		\item Mnemonic for when flags not affected: \texttt{lsr}
		\item Mnemonic for when flags affected: \texttt{lsr.f}
		\item Effect: Logical shift right
		\item Affectable flags:
			\texttt{Z}, \texttt{N}
		%--------
		\end{itemize}
	\item Opcode \texttt{0x8}:
		\texttt{\textbf{asr} rA, rB}
		\begin{itemize}
		%--------
		\item Mnemonic for when flags not affected: \texttt{asr}
		\item Mnemonic for when flags affected: \texttt{asr.f}
		\item Effect: Arithmetic shift right
		\item Affectable flags:
			\texttt{Z}, \texttt{N}
		%--------
		\end{itemize}
	\item Opcode \texttt{0x9}:
		\texttt{\textbf{and} rA, rB}
		\begin{itemize}
		%--------
		\item Mnemonic for when flags not affected: \texttt{and}
		\item Mnemonic for when flags affected: \texttt{and.f}
		\item Effect: Bitwise AND
		\item Affectable flags:
			\texttt{Z}, \texttt{N}
		%--------
		\end{itemize}
	\item Opcode \texttt{0xa}:
		\texttt{\textbf{orr} rA, rB}
		\begin{itemize}
		%--------
		\item Mnemonic for when flags not affected: \texttt{orr}
		\item Mnemonic for when flags affected: \texttt{orr.f}
		\item Effect: Bitwise OR
		\item Affectable flags:
			\texttt{Z}, \texttt{N}
		%--------
		\end{itemize}
	\item Opcode \texttt{0xb}:
		\texttt{\textbf{xor} rA, rB}
		\begin{itemize}
		%--------
		\item Mnemonic for when flags not affected: \texttt{xor}
		\item Mnemonic for when flags affected: \texttt{xor.f}
		\item Effect: Bitwise XOR
		\item Affectable flags:
			\texttt{Z}, \texttt{N}
		%--------
		\end{itemize}
	\item Opcode \texttt{0xc}:
		\texttt{\textbf{adc} rA, rB}
		\begin{itemize}
		%--------
		\item Mnemonic for when flags not affected: \texttt{adc}
		\item Mnemonic for when flags affected: \texttt{adc.f}
		\item Effect: Add with Carry, using the formula
			\texttt{rA + rB + flags.C} to compute the value that will be
			written into \texttt{rA}.
		\item Affectable flags:
			\texttt{Z}, \texttt{C}, \texttt{V}, \texttt{N}
		%--------
		\end{itemize}
	\item Opcode \texttt{0xd}:
		\texttt{\textbf{sbc} rA, rB}
		\begin{itemize}
		%--------
		\item Mnemonic for when flags not affected: \texttt{sbc}
		\item Mnemonic for when flags affected: \texttt{sbc.f}
		\item Effect: Subtract with Borrow, using the formula
			\texttt{rA + (~rB) + flags.C} to compute the value that will be
			written into \texttt{rA}.
		\item Affectable flags:
			\texttt{Z}, \texttt{C}, \texttt{V}, \texttt{N}
		%--------
		\end{itemize}
	\item Opcode \texttt{0xe}:
		\texttt{\textbf{cmpbc} rA, rB}
		\begin{itemize}
		%--------
		\item Effect: Compare \texttt{rA} to \texttt{rB},
			but with carry-in and a different effect for setting the
			\texttt{flags.Z}.
			\texttt{cmpbc} is \textit{always} able to affect
			\texttt{flags}, independent of the encoded \texttt{f} bit of
			the instruction.
		\item Note: this instruction acts much like
			\texttt{\textbf{sbc} rA, rB}, but without storing the
			subtraction's result into \texttt{rA}.
			However, this instruction sets the \texttt{Z} flag to
			\texttt{prev(flags.Z) AND ((rA + (~rB) + flags.C) == 0)}
		\item Affectable flags:
			\texttt{Z}, \texttt{C}, \texttt{V}, \texttt{N}
		%--------
		\end{itemize}
	%\item Opcode \texttt{0xe}:
	%	\texttt{\textbf{ludiv} rA, rB}
	%	\begin{itemize}
	%	%--------
	%	\item Effect: performs a 64-bit by 64-bit unsigned division of
	%	\texttt{\{hi, lo\}} by \texttt{\{rA, rB\}}, storing 64-bit
	%	result in \texttt{\{hi, lo\}}.
	%	\item Note: This instruction executes more quickly if
	%	\texttt{rA}'s value is \texttt{0x00000000}, i.e. if the
	%	operation is actually a 64-bit by 32-bit -> 64-bit unsigned
	%	divide.
	%	%--------
	%	\end{itemize}
	%\item Opcode \texttt{0xf}:
	%	\texttt{\textbf{lsdiv} rA, rB}
	%	\begin{itemize}
	%	%--------
	%	\item Effect: performs a 64-bit by 64-bit signed division of
	%	\texttt{\{hi, lo\}} by \texttt{\{rA, rB\}}, storing 64-bit
	%	result in \texttt{\{hi, lo\}}.
	%	\item Note: This instruction executes more quickly if
	%	\texttt{rA}'s value is either \texttt{0x00000000} or
	%	\texttt{0xffffffff},  i.e. if the operation is actually a
	%	64-bit by 32-bit -> 64-bit signed divide.
	%	%--------
	%	\end{itemize}
	%--------
	\end{itemize}


	\doublespacing
	\subsection{Instruction Group 3: Relative Branches}
	The following encoding is used, with each character representing one
	bit: \\
	\texttt{011i iiii iiii oooo}, where

	\singlespacing
	\begin{itemize}
	%--------
	\item \texttt{i} is a 9-bit sign-extended immediate, and is denoted
	\texttt{simm}
	\item \texttt{o} is the opcode
	%\item \texttt{i} is a 9-bit sign-extended immediate, which can
	%still be affected by \texttt{pre}, but when \texttt{pre} is the
	%instruction before this one, only bits \texttt{[4:0]} of the
	%immediate value encoded into this instruction will be used by the
	%hardware, with the remaining bits of the immediate coming from
	%however many \texttt{pre} instructions were used. Multiple
	%\texttt{pre} instructions can still form larger than 18-bit branch
	%offsets. This immediate is denoted \texttt{simm}.
	%--------
	\end{itemize}
	\doublespacing

	Here is a list of instructions from this encoding group.

	\singlespacing
	\begin{itemize}
	%--------
	%\item Opcode \texttt{0x0}:
	%	\texttt{\textbf{bnv} simm}
	%	\begin{itemize}
	%	%--------
	%	\item Effect:
	%		\texttt{if (0) pc <= pc + simm + 2;} This is a NOP.
	%	%--------
	%	\end{itemize}
	\item Opcode \texttt{0x0}:
		\texttt{\textbf{bl} simm}
		\begin{itemize}
		%--------
		\item Name: Branch and Link
		\item Description: Relative call
		\item Effect:
			\texttt{lr <= pc + 2; pc <= pc + simm + 2;}
		%--------
		\end{itemize}

	\item Opcode \texttt{0x1}:
		\texttt{\textbf{bra} simm}
		\begin{itemize}
		%--------
		\item Name: BRanch Always
		\item Description: Unconditional relative branch
		\item Effect:
			\texttt{pc <= pc + simm + 2;}
		%--------
		\end{itemize}

	\item Opcode \texttt{0x2}:
		\texttt{\textbf{beq} simm}
		\begin{itemize}
		%--------
		\item Name: Branch if EQual
		\item Effect:
			\texttt{if (flags.Z) pc <= pc + simm + 2;}
		%--------
		\end{itemize}

	\item Opcode \texttt{0x3}:
		\texttt{\textbf{bne} simm}
		\begin{itemize}
		%--------
		\item Name: Branch if Not Equal
		\item Effect:
			\texttt{if (!flags.Z) pc <= pc + simm + 2;}
		%--------
		\end{itemize}

	\item Opcode \texttt{0x4}:
		\texttt{\textbf{bmi} simm}
		\begin{itemize}
		%--------
		\item Name: Branch if MInus
		\item Effect:
			\texttt{if (flags.N) pc <= pc + simm + 2;}
		%--------
		\end{itemize}

	\item Opcode \texttt{0x5}:
		\texttt{\textbf{bpl} simm}
		\begin{itemize}
		%--------
		\item Name: Branch if PLus
		\item Effect:
			\texttt{if (!flags.N) pc <= pc + simm + 2;}
		%--------
		\end{itemize}

	\item Opcode \texttt{0x6}:
		\texttt{\textbf{bvs} simm}
		\begin{itemize}
		%--------
		\item Name: Branch if oVerflow Set
		\item Effect:
			\texttt{if (flags.V) pc <= pc + simm + 2;}
		%--------
		\end{itemize}

	\item Opcode \texttt{0x7}:
		\texttt{\textbf{bvc} simm}
		\begin{itemize}
		%--------
		\item Name: Branch if oVerflow Clear
		\item Effect:
			\texttt{if (!flags.V) pc <= pc + simm + 2;}
		%--------
		\end{itemize}

	\item Opcode \texttt{0x8}:
		\texttt{\textbf{bgeu} simm}
		\begin{itemize}
		%--------
		\item Name: Branch if Greater than or Equal Unsigned
		\item Effect:
			\texttt{if (flags.C) pc <= pc + simm + 2;}
		%--------
		\end{itemize}

	\item Opcode \texttt{0x9}:
		\texttt{\textbf{bltu} simm}
		\begin{itemize}
		%--------
		\item Name: Branch if Less Than Unsigned
		\item Effect:
			\texttt{if (!flags.C) pc <= pc + simm + 2;}
		%--------
		\end{itemize}

	\item Opcode \texttt{0xa}:
		\texttt{\textbf{bgtu} simm}
		\begin{itemize}
		%--------
		\item Name: Branch if Greater Than Unsigned
		\item Effect:
			\texttt{if (flags.C AND !flags.Z) pc <= pc + simm + 2;}
		%--------
		\end{itemize}

	\item Opcode \texttt{0xb}:
		\texttt{\textbf{bleu} simm}
		\begin{itemize}
		%--------
		\item Name: Branch if Less than or Equal Unsigned
		\item Effect:
			\texttt{if (!flags.C OR flags.Z) pc <= pc + simm + 2;}
		%--------
		\end{itemize}

	\item Opcode \texttt{0xc}:
		\texttt{\textbf{bges} simm}
		\begin{itemize}
		%--------
		\item Name: Branch if Greater than or Equal Signed
		\item Effect:
			\texttt{if (!(flags.N XOR flags.V)) pc <= pc + simm + 2;}
		%--------
		\end{itemize}

	\item Opcode \texttt{0xd}:
		\texttt{\textbf{blts} simm}
		\begin{itemize}
		%--------
		\item Name: Branch if Less Than Signed
		\item Effect:
			\texttt{if (flags.N XOR flags.V) pc <= pc + simm + 2;}
		%--------
		\end{itemize}

	\item Opcode \texttt{0xe}:
		\texttt{\textbf{bgts} simm}
		\begin{itemize}
		%--------
		\item Name: Branch if Greater Than Signed
		\item Effect:
			\texttt{if (!(flags.N XOR flags.V) AND !flags.Z)
				pc <= pc + simm + 2;}
		%--------
		\end{itemize}

	\item Opcode \texttt{0xf}:
		\texttt{\textbf{bles} simm}
		\begin{itemize}
		%--------
		\item Name: Branch if Less than or Equal Signed
		\item Effect:
			\texttt{if ((flags.N XOR flags.V) OR flags.Z)
				pc <= pc + simm + 2;}
		%--------
		\end{itemize}
	%--------
	\end{itemize}

	\doublespacing
	\subsection{Instruction Group 4}
	The following encoding is used, with each character representing one
	bit: \\
	\texttt{100o oooo bbbb aaaa}, where

	\singlespacing
	\begin{itemize}
	%--------
	\item \texttt{o} is the opcode
	\item \texttt{b} encodes register \texttt{rB} or register
	\texttt{sC}, where \texttt{sC} is one of the special-purpose registers
	\item \texttt{a} encodes register \texttt{rA} or register
	\texttt{sA}, where \texttt{sA} is one of the special-purpose registers
	%--------
	\end{itemize}
	\doublespacing

	Here is a list of instructions from this encoding group.

	\singlespacing
	\begin{itemize}
	%--------
	\item Opcode \texttt{0x0}:
		\texttt{\textbf{jl} rA}
		\begin{itemize}
		%--------
		\item Effect: \texttt{lr <= pc + 2; pc <= rA;}
		%--------
		\end{itemize}
	\item Opcode \texttt{0x1}:
		\texttt{\textbf{jmp} rA}
		\begin{itemize}
		%--------
		\item Effect: \texttt{pc <= rA;}
		%--------
		\end{itemize}
	%\item Opcode \texttt{0x2}:
	%	\texttt{\textbf{jmp} rA, rB}
	%	\begin{itemize}
	%	%--------
	%	\item Effect: \texttt{pc <= (rA + rB);}
	%	%--------
	%	\end{itemize}
	\item Opcode \texttt{0x2}:
		\texttt{\textbf{jmp} ira}
		\begin{itemize}
		%--------
		\item Effect: \texttt{pc <= ira;}
		%--------
		\end{itemize}
	\item Opcode \texttt{0x3}:
		\texttt{\textbf{reti}}
		\begin{itemize}
		%--------
		\item Effect: enables IRQs (by copying \texttt{0x1} into
		\texttt{ie}) and performs \texttt{pc <= ira;}
		%--------
		\end{itemize}
	\item Opcode \texttt{0x4}:
		\texttt{\textbf{ei}}
		\begin{itemize}
		%--------
		\item Effect: copy \texttt{1} into \texttt{ie}.
		%--------
		\end{itemize}
	\item Opcode \texttt{0x5}:
		\texttt{\textbf{di}}
		\begin{itemize}
		%--------
		\item Effect: copy \texttt{0} into \texttt{ie}.
		%--------
		\end{itemize}
	\item Opcode \texttt{0x6}:
		\texttt{\textbf{push} rA, rB}
		\begin{itemize}
		%--------
		%\item Pseudo instruction with same effect: 
		%	\begin{itemize}
		%	%--------
		%	\item \texttt{\textbf{strda} rA, [rB]}
		%	\item Name: store register, decrement base after
		%	%--------
		%	\end{itemize}
		\item Effect: pushes \texttt{rA} onto the stack, using
		\texttt{rB} as the stack pointer, post-decrementing
		\texttt{rB}.
		\item This instruction does nothing when \texttt{rA} is the
		same register as \texttt{rB}. 
		\item Note: As a pseudo instruction, omitting "\texttt{, rB}" will
			automatically select \texttt{sp} as the particular stack
			pointer. 
		\texttt{sp}
		%--------
		\end{itemize}
	\item Opcode \texttt{0x7}:
		\texttt{\textbf{push} sA, rB}
		\begin{itemize}
		%--------
		%\item Pseudo instruction with same effect: 
		%	\begin{itemize}
		%	%--------
		%	\item \texttt{\textbf{strda} sA, [rB]}
		%	\item Name: store register, decrement base after
		%	%--------
		%	\end{itemize}
		\item Effect: pushes \texttt{sA} onto the stack, using
		\texttt{rB} as the stack pointer, post-decrementing
		\texttt{rB}.
		\item Note that \texttt{sA} is considered to be 32-bit for the
		purpose of the store to memory and decrementing \texttt{rB},
		even if \texttt{sA} is \texttt{flags} or \texttt{ie}.
		\item Note: As a pseudo instruction, omitting "\texttt{, rB}" will
			automatically select \texttt{sp} as the particular stack
			pointer. 
		%--------
		\end{itemize}
	\item Opcode \texttt{0x8}:
		\texttt{\textbf{pop} rA, rB}
		\begin{itemize}
		%--------
		%\item Pseudo instruction with same effect: 
		%	\begin{itemize}
		%	%--------
		%	\item \texttt{\textbf{ldrib} rA, rB}
		%	\item Name: load register, increment base before
		%	%--------
		%	\end{itemize}
		\item Effect: pops \texttt{rA} off the stack, using
		\texttt{rB} as the stack pointer, pre-incrementing \texttt{rB}.
		\item This instruction does nothing when \texttt{rA} is the
		same register as \texttt{rB}. 
		\item Note: As a pseudo instruction, omitting "\texttt{, rB}" will
			automatically select \texttt{sp} as the particular stack
			pointer. 
		%--------
		\end{itemize}
	\item Opcode \texttt{0x9}:
		\texttt{\textbf{pop} sA, rB}
		\begin{itemize}
		%--------
		\item Pseudo instruction with same effect: 
			\begin{itemize}
			%--------
			\item \texttt{\textbf{ldrib} sA, rB}
			\item Name explanation: load register, increment base before
			%--------
			\end{itemize}
		\item Effect: pops \texttt{sA} off the stack, using
		\texttt{rB} as the stack pointer, pre-incrementing \texttt{rB}.
		\item Note that \texttt{sA} is considered to be 32-bit for the
		purpose of the load from memory and incrementing \texttt{rB},
		even if \texttt{sA} is \texttt{flags} or \texttt{ie}.
		\item Note: As a pseudo instruction, omitting "\texttt{, rB}" will
			automatically select \texttt{sp} as the particular stack
			pointer. 
		%--------
		\end{itemize}
	\item Opcode \texttt{0xa}:
		\texttt{\textbf{pop} pc, rB}
		\begin{itemize}
		%--------
		\item Pseudo instruction with same effect: 
			\begin{itemize}
			%--------
			\item \texttt{\textbf{ldrib} pc, rB}
			\item Name explanation: load register, increment base before
			%--------
			\end{itemize}
		\item Effect: pops \texttt{pc} off the stack, using
		\texttt{rB} as the stack pointer, pre-incrementing \texttt{rB}.
		\item Note that \texttt{pc} is considered to be 32-bit for the
		purpose of the load from memory and incrementing \texttt{rB},
		even if \texttt{pc} is \texttt{flags} or \texttt{ie}.
		\item Note: As a pseudo instruction, omitting "\texttt{, rB}" will
			automatically select \texttt{sp} as the particular stack
			pointer. 
		%--------
		\end{itemize}
	\item Opcode \texttt{0xb}:
		\texttt{\textbf{mul} rA, rB}
		\begin{itemize}
		%--------
		\item Effect: \texttt{rA <= rA * rB;}
		%--------
		\end{itemize}
	\item Opcode \texttt{0xc}:
		\texttt{\textbf{udiv} rA, rB}
		\begin{itemize}
		%--------
		\item Effect: \texttt{rA <= u32(rA) / u32(rB);}
		%--------
		\end{itemize}
	\item Opcode \texttt{0xd}:
		\texttt{\textbf{sdiv} rA, rB}
		\begin{itemize}
		%--------
		\item Effect: \texttt{rA <= s32(rA) / s32(rB);}
		%--------
		\end{itemize}
	\item Opcode \texttt{0xe}:
		\texttt{\textbf{umod} rA, rB}
		\begin{itemize}
		%--------
		\item Effect: \texttt{rA <= u32(rA) \% u32(rB);}
		%--------
		\end{itemize}
	\item Opcode \texttt{0xf}:
		\texttt{\textbf{smod} rA, rB}
		\begin{itemize}
		%--------
		\item Effect: \texttt{rA <= s32(rA) \% s32(rB);}
		%--------
		\end{itemize}
	\item Opcode \texttt{0x10}:
		\texttt{\textbf{lumul} rA, rB}
		\begin{itemize}
		%--------
		\item Effect: This instruction multiplies \texttt{rA} by
			\texttt{rB}, performing an unsigned 32-bit by 32-bit -> 64-bit
			multiply, storing result in \texttt{concat\{r0, r1\}}.
		%\item Effect: This instruction multiplies
		%	%\texttt{concat\{rA, r\{A+1\}\}}
		%	%by \texttt{concat\{rB, r\{B+1\}\}},
		%	\texttt{rA} by \texttt{rB},
		%	performing an unsigned 32-bit by 32-bit -> 64-bit multiply,
		%	storing 64-bit result in
		%	\texttt{concat\{rA, r\{A+1\}\}}.
		%\item Note: This instruction operates as if
		%	\texttt{rA} were encoded with \texttt{(A[0x0] == 0b0)}.
		%	%and
		%	%\texttt{rB} were encoded with \texttt{(B[0x0] == 0b0)},
		%--------
		\end{itemize}
	\item Opcode \texttt{0x11}:
		\texttt{\textbf{lsmul} rA, rB}
		\begin{itemize}
		%--------
		\item Effect: This instruction multiplies \texttt{rA} by
		\texttt{rB}, performing a signed 32-bit by 32-bit -> 64-bit
		multiply, storing result in \texttt{concat\{r0, r1\}}.
		%\item Effect: This instruction multiplies
		%	%\texttt{concat\{rA, r\{A+1\}\}}
		%	%by \texttt{concat\{rB, r\{B+1\}\}},
		%	\texttt{rA} by \texttt{rB},
		%	performing a signed 32-bit by 32-bit -> 64-bit multiply,
		%	storing 64-bit result in
		%	\texttt{concat\{rA, r\{A+1\}\}}.
		%\item Note: This instruction operates as if
		%	\texttt{rA} were encoded with \texttt{(A[0x0] == 0b0)}
		%	and
		%	\texttt{rB} were encoded with \texttt{(B[0x0] == 0b0)},
		%--------
		\end{itemize}
	\item Opcode \texttt{0x12}:
		\texttt{\textbf{ludiv} rA, rB}
		\begin{itemize}
		%--------
		%\item Effect: performs a 64-bit by 64-bit unsigned division of
		%	\texttt{\{r0, r1\}} by \texttt{\{rA, rB\}}, storing 64-bit
		%	result in \texttt{\{r0, r1\}}.
		%\item Note: This instruction executes more quickly if
		%	\texttt{rA}'s value is \texttt{0x00000000}, i.e. if the
		%	operation is actually a 64-bit by 32-bit -> 64-bit unsigned
		%	divide.
		\item Effect: performs a 64-bit by 64-bit unsigned division of
			\texttt{concat\{rA, r\{A + 1\}\}}
			by \texttt{concat\{rB, r\{B + 1\}\}},
			storing 64-bit result in
			\texttt{concat\{rA, r\{A + 1\}\}}.
		\item Note: This instruction operates as if
			\texttt{rA} were encoded with \texttt{(A[0x0] == 0b0)}
			and
			\texttt{rB} were encoded with \texttt{(B[0x0] == 0b0)},
		\item Note: This instruction executes more quickly if
			\texttt{rB}'s value is \texttt{0x00000000}, i.e. if the
			operation is actually a 64-bit by 32-bit -> 64-bit unsigned
			divide.
		%--------
		\end{itemize}
	\item Opcode \texttt{0x13}:
		\texttt{\textbf{lsdiv} rA, rB}
		\begin{itemize}
		%--------
		%\item Effect: performs a 64-bit by 64-bit signed division of
		%	\texttt{\{r0, r1\}} by \texttt{\{rA, rB\}}, storing 64-bit
		%	result in \texttt{\{r0, r1\}}.
		%\item Note: This instruction executes more quickly if
		%	\texttt{rA}'s value is either \texttt{0x00000000} or
		%	\texttt{0xffffffff},  i.e. if the operation is actually a
		%	64-bit by 32-bit -> 64-bit signed divide.
		%\item Note: This instruction executes more quickly if
		%	\texttt{rA} is equal to bits \texttt{[63:32]} of
		%	\texttt{sign\_extend\_to\_64(rB)}.
		\item Effect: performs a 64-bit by 64-bit signed division of
			\texttt{concat\{rA, r\{A + 1\}\}}
			by \texttt{concat\{rB, r\{B + 1\}\}},
			storing 64-bit result in
			\texttt{concat\{rA, r\{A + 1\}\}}.
		\item Note: This instruction operates as if
			\texttt{rA} were encoded with \texttt{(A[0x0] == 0b0)}
			and
			\texttt{rB} were encoded with \texttt{(B[0x0] == 0b0)},
		\item Note: This instruction executes more quickly if
			\texttt{rB} is equal to bits \texttt{[63:32]} of
			\texttt{s64(r\{B+1\})}.
		%--------
		\end{itemize}
	\item Opcode \texttt{0x14}:
		\texttt{\textbf{lumod} rA, rB}
		\begin{itemize}
		%--------
		%\item Effect: performs a 64-bit by 64-bit unsigned modulo of
		%	\texttt{\{r0, r1\}} by \texttt{\{rA, rB\}}, storing 64-bit
		%	result in \texttt{\{r0, r1\}}.
		%\item Note: This instruction executes more quickly if
		%	\texttt{rA}'s value is \texttt{0x00000000}, i.e. if the
		%	operation is actually a 64-bit by 32-bit -> 64-bit unsigned
		%	modulo.
		\item Effect: performs a 64-bit by 64-bit unsigned modulo of
			\texttt{concat\{rA, r\{A + 1\}\}}
			by \texttt{concat\{rB, r\{B + 1\}\}},
			storing 64-bit result in
			\texttt{concat\{rA, r\{A + 1\}\}}.
		\item Note: This instruction operates as if
			\texttt{rA} were encoded with \texttt{(A[0x0] == 0b0)}
			and
			\texttt{rB} were encoded with \texttt{(B[0x0] == 0b0)},
		\item Note: This instruction executes more quickly if
			\texttt{rB}'s value is \texttt{0x00000000}, i.e. if the
			operation is actually a 64-bit by 32-bit -> 64-bit unsigned
			modulo.
		%--------
		\end{itemize}
	\item Opcode \texttt{0x15}:
		\texttt{\textbf{lsmod} rA, rB}
		\begin{itemize}
		%--------
		%\item Effect: performs a 64-bit by 64-bit signed modulo of
		%	\texttt{\{r0, r1\}} by \texttt{\{rA, rB\}}, storing 64-bit
		%	result in \texttt{\{r0, r1\}}.
		%\item Note: This instruction executes more quickly if
		%	\texttt{rA} is equal to bits \texttt{[63:32]} of
		%	\texttt{sign\_extend\_to\_64(rB)}.
		\item Effect: performs a 64-bit by 64-bit signed modulo of
			\texttt{concat\{rA, r\{A + 1\}\}}
			by \texttt{concat\{rB, r\{B + 1\}\}},
			storing 64-bit result in
			\texttt{concat\{rA, r\{A + 1\}\}}.
		\item Note: This instruction operates as if
			\texttt{rA} were encoded with \texttt{(A[0x0] == 0b0)}
			and
			\texttt{rB} were encoded with \texttt{(B[0x0] == 0b0)},
		\item Note: This instruction executes more quickly if
			\texttt{rB} is equal to bits \texttt{[63:32]} of
			\texttt{s64(r\{B+1\})}.
		%--------
		\end{itemize}
	\item Opcode \texttt{0x16}:
		\texttt{\textbf{ldub} rA, [rB]}
		\begin{itemize}
		%--------
		\item Effect: Load an 8-bit value from memory at address
		computed as \texttt{rB + <index\_reg>}, zero-extend
		the 8-bit value to 32 bits, then put the zero-extended 32-bit
		value into \texttt{rA}.
		\item The \texttt{<index\_reg>} value is guaranteed to be zero
		unless an \texttt{index} is in effect.
		\item Shorthand for having the assembler insert an
		\texttt{index rC} instruction before this one:
			\texttt{ldub rA, [rB, rC]}
		%--------
		\end{itemize}
	\item Opcode \texttt{0x17}:
		\texttt{\textbf{ldsb} rA, [rB]}
		\begin{itemize}
		%--------
		\item Effect: Load an 8-bit value from memory at address
		computed as \texttt{rB + <index\_reg>}, sign-extend
		the 8-bit value to 32 bits, then put the sign-extended 32-bit
		value into \texttt{rA}.
		\item The \texttt{<index\_reg>} value is guaranteed to be zero
		unless an \texttt{index} is in effect.
		\item Shorthand for having the assembler insert an
		\texttt{index rC} instruction before this one:
			\texttt{ldsb rA, [rB, rC]}
		%--------
		\end{itemize}
	\item Opcode \texttt{0x18}:
		\texttt{\textbf{lduh} rA, [rB]}
		\begin{itemize}
		%--------
		\item Effect: Load a 16-bit value from memory at address
		computed as \texttt{rB + <index\_reg>}, zero-extend
		the 16-bit value to 32 bits, then put the zero-extended 32-bit
		value into \texttt{rA}.
		\item The \texttt{<index\_reg>} value is guaranteed to be zero
		unless an \texttt{index} is in effect.
		\item Shorthand for having the assembler insert an
		\texttt{index rC} instruction before this one:
			\texttt{lduh rA, [rB, rC]}
		%--------
		\end{itemize}
	\item Opcode \texttt{0x19}:
		\texttt{\textbf{ldsh} rA, [rB]}
		\begin{itemize}
		%--------
		\item Effect: Load a 16-bit value from memory at address
		computed as \texttt{rB + <index\_reg>}, sign-extend
		the 16-bit value to 32 bits, then put the zero-extended 32-bit
		value into \texttt{rA}.
		\item The \texttt{<index\_reg>} value is guaranteed to be zero
		unless an \texttt{index} is in effect.
		\item Shorthand for having the assembler insert an
		\texttt{index rC} instruction before this one:
			\texttt{ldsh rA, [rB, rC]}
		%--------
		\end{itemize}
	\item Opcode \texttt{0x1a}:
		\texttt{\textbf{stb} rA, [rB]}
		\begin{itemize}
		%--------
		\item Effect: Store \texttt{rA[7:0]} to memory at the address
		computed as \texttt{rB + <index\_reg>}.
		\item The \texttt{<index\_reg>} value is guaranteed to be zero
		unless an \texttt{index} is in effect.
		\item Shorthand for having the assembler insert an
		\texttt{index rC} instruction before this one:
			\texttt{stb rA, [rB, rC]}
		%--------
		\end{itemize}
	\item Opcode \texttt{0x1b}:
		\texttt{\textbf{sth} rA, [rB]}
		\begin{itemize}
		%--------
		\item Effect: Store \texttt{rA[15:0]} to memory at the address
		computed as \texttt{rB + <index\_reg>}.
		\item The \texttt{<index\_reg>} value is guaranteed to be zero
		unless an \texttt{index} is in effect.
		\item Shorthand for having the assembler insert an
		\texttt{index rC} instruction before this one:
			\texttt{sth rA, [rB, rC]}
		%--------
		\end{itemize}
	\item Opcode \texttt{0x1c}:
		\texttt{\textbf{cpy} rA, sC}
		\begin{itemize}
		%--------
		\item Effect: \texttt{rA <= sC;}
		%--------
		\end{itemize}
	\item Opcode \texttt{0x1d}:
		\texttt{\textbf{cpy} sA, rB}
		\begin{itemize}
		%--------
		\item Effect: \texttt{sA <= rB;}
		%--------
		\end{itemize}
	\item Opcode \texttt{0x1e}:
		\texttt{\textbf{cpy} sA, sB}
		\begin{itemize}
		%--------
		\item Effect: \texttt{sA <= sB;}
		%--------
		\end{itemize}
	\item Opcode \texttt{0x1f}:
		\texttt{\textbf{index} rA}
		\begin{itemize}
		%--------
		\item Effect: Performs \texttt{<index\_reg> <= rA;} and stores
		that \texttt{index} is in effect.
		\item Note: If \texttt{index} is in effect and the current
		instruction is \texttt{index}, the current instruction will be
		treated as a NOP, and \texttt{index} will stop being in effect.
		\item Note: \texttt{pre} and \texttt{index} can be combined
		with one another (though this is only useful for \texttt{ldr}
		and \texttt{str}).
		\item Note: A non-\texttt{pre} instruction following
		\texttt{index} will store that that \texttt{index} is not in
		effect any more. (It will also store that \texttt{pre} is not
		in effect any more).
		\item Note: If \texttt{index} is in effect, the current
		instruction cannot be interrupted by an IRQ.
		\item Note: Any time \texttt{index} stops being in effect,
		\texttt{pre} will stop being in effect as well.
		%--------
		\end{itemize}
	%--------
	\end{itemize}

	\doublespacing
	\subsection{Instruction Group 5: Immediate Indexed Load}
	The following encoding is used, with each character representing one
	bit: \\
	\texttt{101i iiii bbbb aaaa}, where

	\singlespacing
	\begin{itemize}
	%--------
	\item \texttt{i} is a 5-bit sign-extended immediate, which can
	be expanded by \texttt{pre}, and is denoted \texttt{simm}
	\item \texttt{b} encodes register \texttt{rB}
	\item \texttt{a} encodes register \texttt{rA}
	%--------
	\end{itemize}
	\doublespacing

	The one instruction from this encoding group is
	\texttt{\textbf{ldr} rA, [rB, \#simm]}.
	This is a 32-bit load into \texttt{rA}, where the effective address to
	load from is computed as \texttt{rB + <index\_reg> + simm}, using the
	sign-extended form of \texttt{simm}.

	The \texttt{<index\_reg>} value is guaranteed to be zero unless an
	\texttt{index} is in effect.

	Shorthand for having the assembler insert an \texttt{index rC}
	instruction before this one: \texttt{ldr rA, [rB, rC, \#simm]}

	%The \texttt{<index\_reg>} value is zero in all cases except
	%the previous instruction was \texttt{index index\_reg} and if
	%\texttt{index\_reg}'s value was non-zero. 

	\subsection{Instruction Group 6: Immediate Indexed Store}
	The following encoding is used, with each character representing one
	bit: \\
	\texttt{110i iiii bbbb aaaa}, where

	\singlespacing
	\begin{itemize}
	%--------
	\item \texttt{i} is a 5-bit sign-extended immediate, which can
	be expanded by \texttt{pre}  
	\item \texttt{b} encodes register \texttt{rB}
	\item \texttt{a} encodes register \texttt{rA}
	%--------
	\end{itemize}
	\doublespacing

	The one instruction from this encoding group is
	\texttt{\textbf{str} rA, [rB, \#simm]}.
	This is a 32-bit store of \texttt{rA}, where the effective address to
	store to is computed as \texttt{<index\_reg> + rB + simm}, using the
	sign-extended form of \texttt{simm}.

	The \texttt{<index\_reg>} value is guaranteed to be zero unless an
	\texttt{index} is in effect.

	Shorthand for having the assembler insert an \texttt{index rC}
	instruction before this one: \texttt{str rA, [rB, rC, \#simm]}

	%The \texttt{index\_reg} value is zero in all cases except
	%the previous instruction was \texttt{index index\_reg} and if
	%\texttt{index\_reg}'s value was non-zero. 

	\doublespacing

	\subsection{Instruction Group 7, Subgroup \texttt{0b00}:
		Extra 8-bit and 16-bit Ops}
	The following encoding is used, with each character representing one
	bit: \\
	\texttt{1110 0woo bbbb aaaa}, where

	\singlespacing
	\begin{itemize}
	%--------
	\item \texttt{w} is the operation width
		\begin{itemize}
		%--------
		\item When \texttt{0b0}:
			8-bit operation
		\item When \texttt{0b0}:
			16-bit operation
		%--------
		\end{itemize}
	\item \texttt{o} is the opcode
	\item \texttt{b} encodes register \texttt{rB}
	\item \texttt{a} encodes register \texttt{rA}
	%--------
	\end{itemize}
	\doublespacing

	Here is a list of instructions from this encoding group.

	\singlespacing
	\begin{itemize}
	%--------
	\item Opcode \texttt{0x0}:
		\begin {itemize}
		%--------
		\item \texttt{w} value \texttt{0b0}:
			\texttt{\textbf{cmpb} rA, rB}
			\begin{itemize}
			%--------
			\item Effect: Compare \texttt{rA[7:0]} to \texttt{rB[7:0]}
			\item Affectable flags:
				\texttt{Z}, \texttt{C}, \texttt{V}, \texttt{N}
			%--------
			\end{itemize}
		\item \texttt{w} value \texttt{0b1}:
			\texttt{\textbf{cmph} rA, rB}
			\begin{itemize}
			%--------
			\item Effect: Compare \texttt{rA[15:0]} to \texttt{rB[15:0]}
			\item Affectable flags:
				\texttt{Z}, \texttt{C}, \texttt{V}, \texttt{N}
			%--------
			\end{itemize}
		%--------
		\end{itemize}
	\item Opcode \texttt{0x1}:
		\begin {itemize}
		%--------
		\item \texttt{w} value \texttt{0b0}:
			\texttt{\textbf{lsrb} rA, rB}
			\begin{itemize}
			%--------
			\item Effect:
				Logical shift right \texttt{rA[7:0]} by \texttt{rB}
			%--------
			\end{itemize}
		\item \texttt{w} value \texttt{0b1}:
			\texttt{\textbf{lsrh} rA, rB}
			\begin{itemize}
			%--------
			\item Effect:
				Logical shift right \texttt{rA[15:0]} by \texttt{rB}
			%--------
			\end{itemize}
		%--------
		\end{itemize}
	\item Opcode \texttt{0x2}:
		\begin {itemize}
		%--------
		\item \texttt{w} value \texttt{0b0}:
			\texttt{\textbf{asrb} rA, rB}
			\begin{itemize}
			%--------
			\item Effect:
				Arithmetic shift right
				\texttt{rA[7:0]} by \texttt{rB}
			%--------
			\end{itemize}
		\item \texttt{w} value \texttt{0b1}:
			\texttt{\textbf{asrh} rA, rB}
			\begin{itemize}
			%--------
			\item Effect:
				Arithmetic shift right
					\texttt{rA[15:0]} by \texttt{rB}
			%--------
			\end{itemize}
		%--------
		\end{itemize}
	%--------
	\end{itemize}

	\doublespacing

	\subsection{Instruction Group 7, Subgroup \texttt{0b010}:
		Extra load/store instructions}
	The following encoding is used, with each character representing one
	bit: \\
	\texttt{1110 10oo bbbb aaaa}, where

	\singlespacing
	\begin{itemize}
	%--------
	\item \texttt{o} is the opcode
	\item \texttt{b} encodes register \texttt{sA}
	\item \texttt{a} encodes register \texttt{rB} or \texttt{sB}
	%--------
	\end{itemize}
	\doublespacing

	Here is a list of instructions from this encoding group.

	\singlespacing
	\begin{itemize}
	%--------
	\item Opcode \texttt{0x0}:
		\texttt{\textbf{ldr} sA, [rB]}
		\begin{itemize}
		%--------
		\item Effect: 32-bit load of \texttt{sA} from memory at address
			held in \texttt{rB}.
		%--------
		\end{itemize}
	\item Opcode \texttt{0x1}:
		\texttt{\textbf{ldr} sA, [sB]}
		\begin{itemize}
		%--------
		\item Effect: 32-bit load of \texttt{sA} from memory at address
			held in \texttt{sB}.
		%--------
		\end{itemize}
	\item Opcode \texttt{0x2}:
		\texttt{\textbf{str} sA, [rB]}
		\begin{itemize}
		%--------
		\item Effect: 32-bit store of \texttt{sA} to memory at address
			held in \texttt{rB}.
		%--------
		\end{itemize}
	\item Opcode \texttt{0x3}:
		\texttt{\textbf{str} sA, [sB]}
		\begin{itemize}
		%--------
		\item Effect: 32-bit store of \texttt{sA} to memory at address
			held in \texttt{sB}.
		%--------
		\end{itemize}
	%--------
	\end{itemize}


	%\printbibliography[heading=bibnumbered,title={Bibliography}]

\end{document}

