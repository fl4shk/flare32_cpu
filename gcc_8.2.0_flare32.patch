diff -x build-x86_64-pc-linux-gnu -x host-x86_64-pc-linux-gnu -x config.log -x config.status -x flare32-elf -x '*.taghl' -x tags -x Makefile -Nur gcc-8.2.0/config.sub gcc-8.2.0-flare32/config.sub
--- gcc-8.2.0/config.sub	2018-01-02 23:25:18.000000000 -0500
+++ gcc-8.2.0-flare32/config.sub	2018-12-02 08:24:57.914953797 -0500
@@ -258,6 +258,7 @@
 	| d10v | d30v | dlx | dsp16xx \
 	| e2k | epiphany \
 	| fido | fr30 | frv | ft32 \
+	| flare32 \
 	| h8300 | h8500 | hppa | hppa1.[01] | hppa2.0 | hppa2.0[nw] | hppa64 \
 	| hexagon \
 	| i370 | i860 | i960 | ia16 | ia64 \
diff -x build-x86_64-pc-linux-gnu -x host-x86_64-pc-linux-gnu -x config.log -x config.status -x flare32-elf -x '*.taghl' -x tags -x Makefile -Nur gcc-8.2.0/gcc/config/flare32/flare32_actual.hpp gcc-8.2.0-flare32/gcc/config/flare32/flare32_actual.hpp
--- gcc-8.2.0/gcc/config/flare32/flare32_actual.hpp	1969-12-31 19:00:00.000000000 -0500
+++ gcc-8.2.0-flare32/gcc/config/flare32/flare32_actual.hpp	2018-12-05 09:17:05.795321685 -0500
@@ -0,0 +1,1302 @@
+#define IN_TARGET_CODE 1
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "backend.h"
+#include "target.h"
+#include "rtl.h"
+#include "tree.h"
+#include "stringpool.h"
+#include "attribs.h"
+#include "df.h"
+#include "regs.h"
+#include "memmodel.h"
+#include "emit-rtl.h"
+#include "diagnostic-core.h"
+#include "output.h"
+#include "stor-layout.h"
+#include "varasm.h"
+#include "calls.h"
+#include "expr.h"
+#include "builtins.h"
+
+#include "flare32-protos.h"
+
+/* This file should be included last.  */
+#include "target-def.h"
+
+
+// Per-function machine data.
+struct GTY(()) machine_function
+{
+	static constexpr int STACK_ALIGNMENT = STACK_BOUNDARY / BITS_PER_UNIT;
+
+	// Number of bytes saved on the stack for callee saved registers.
+	int callee_saved_reg_size;
+
+	// Number of bytes saved on the stack for local variables.
+	int local_vars_size;
+
+	// Number of bytes of arguments passed onto the stack.
+	int stack_args_size;
+
+	// The sum of 2 sizes: locals vars and padding byte for saving the
+	// registers.  Used in expand_prologue () and expand_epilogue().
+	int size_for_adjusting_sp;
+
+
+	// Padding for alignment
+	int padding_stack_args, padding_locals;
+
+	void update_stack_args_size()
+	{
+		// Padding needed for each element of the frame.
+		stack_args_size = crtl->args.pretend_args_size;
+
+		// Arguments on the stack should already be aligned?
+		//// Align to the stack alignment
+		//padding_stack_args = stack_args_size % STACK_ALIGNMENT;
+
+		//if (padding_stack_args)
+		//{
+		//	padding_stack_args = STACK_ALIGNMENT - padding_stack_args;
+		//}
+
+		//stack_args_size += padding_stack_args;
+	}
+
+	void update_local_vars_size()
+	{
+		// Padding needed for each element of the frame.
+		local_vars_size = get_frame_size();
+
+		// Align to the stack alignment
+		padding_locals = local_vars_size % STACK_ALIGNMENT;
+
+		if (padding_locals)
+		{
+			padding_locals = STACK_ALIGNMENT - padding_locals;
+		}
+
+		local_vars_size += padding_locals;
+	}
+
+	void update_callee_saved_reg_size()
+	{
+		callee_saved_reg_size = 0;
+
+
+		//fprintf(stderr, "\nmachine_function::update_callee_saved_reg_size"
+		//	"()\n");
+		// Save callee-saved registers
+		for (int regno=0; regno<FIRST_PSEUDO_REGISTER; ++regno)
+		{
+			if (flare32_regno_actually_callee_saved(regno))
+			{
+				callee_saved_reg_size += UNITS_PER_WORD;
+			}
+		}
+	}
+
+	void update_size_for_adjusting_sp()
+	{
+		//machine.size_for_adjusting_sp = crtl->args.pretend_args_size
+		//	+ machine.local_vars_size
+		//	+ (ACCUMULATE_OUTGOING_ARGS
+		//	? static_cast<HOST_WIDE_INT>(crtl->outgoing_args_size) : 0);
+
+		//size_for_adjusting_sp = stack_args_size + UNITS_PER_WORD
+		//	+ callee_saved_reg_size
+		//	+ local_vars_size
+		//	+ (ACCUMULATE_OUTGOING_ARGS
+		//	? static_cast<HOST_WIDE_INT>(crtl->outgoing_args_size) : 0);
+		size_for_adjusting_sp = local_vars_size
+			+ (ACCUMULATE_OUTGOING_ARGS
+			? static_cast<HOST_WIDE_INT>(crtl->outgoing_args_size) : 0);
+	}
+
+	//inline int fp_offset_from_old_sp() const
+	//{
+	//	return (-stack_args_size);
+	//}
+
+	inline int ap_offset_from_fp() const
+	{
+		return (stack_args_size + UNITS_PER_WORD);
+	}
+
+
+};
+
+
+#define LOSE_AND_RETURN(msgid, x) \
+do \
+{ \
+	flare32_operand_lossage(msgid, x); \
+	return; \
+} while (0)
+
+static constexpr int MIN_SIMM18 = -131072;
+static constexpr int MAX_SIMM18 = 131071;
+
+// Define how to find the value returned by a function.
+// VALTYPE is the data type of the value (as a tree).
+// If the precise function being called is known, FUNC is its
+// FUNCTION_DECL; otherwise, FUNC is 0.  
+//
+// We always return values in register $r0 for flare32.
+
+static rtx flare32_function_value(const_tree valtype, 
+	const_tree fntype_or_decl ATTRIBUTE_UNUSED,
+	bool outgoing ATTRIBUTE_UNUSED)
+{
+	return gen_rtx_REG(TYPE_MODE(valtype), FLARE32_R0);
+}
+
+// Define how to find the value returned by a library function.
+//
+// We always return values in register r0 for flare32.
+
+static rtx flare32_libcall_value(machine_mode mode,
+	const_rtx fun ATTRIBUTE_UNUSED)
+{
+	return gen_rtx_REG(mode, FLARE32_R0);
+}
+
+// Handle TARGET_FUNCTION_VALUE_REGNO_P.
+//
+// We always return values in register r0 for flare32.
+
+static bool flare32_function_value_regno_p(const unsigned int regno)
+{
+	return (regno == FLARE32_R0);
+}
+
+// Emit an error message when we're in an asm, and a fatal error for
+// "normal" insns.  Formatted output isn't easily implemented, since we
+// use output_operand_lossage to output the actual message and handle the
+// categorization of the error.
+
+static void flare32_operand_lossage(const char *msgid, rtx op)
+{
+	debug_rtx(op);
+	output_operand_lossage("%s", msgid);
+}
+
+
+static bool flare32_regno_ok_for_base_p(const_rtx reg, bool strict_p)
+{
+	const int regno = REGNO(reg);
+
+	if (strict_p)
+	{
+		return (HARD_REGNO_OK_FOR_BASE_P(regno)
+			|| HARD_REGNO_OK_FOR_BASE_P(reg_renumber[regno]));
+	}
+	else    
+	{
+		return ((!HARD_REGISTER_NUM_P(regno))
+			|| HARD_REGNO_OK_FOR_BASE_P(regno));
+	}
+}
+static bool flare32_regno_ok_for_index_p(const_rtx reg, bool strict_p)
+{
+	const int regno = REGNO(reg);
+
+	if (strict_p)
+	{
+		return (HARD_REGNO_OK_FOR_INDEX_P(regno)
+			|| HARD_REGNO_OK_FOR_INDEX_P(reg_renumber[regno]));
+	}
+	else    
+	{
+		return ((!HARD_REGISTER_NUM_P(regno))
+			|| HARD_REGNO_OK_FOR_INDEX_P(regno));
+	}
+}
+
+static bool flare32_legitimate_address_p(machine_mode mode, rtx x,
+	bool strict_p, addr_space_t as)
+{
+	gcc_assert(ADDR_SPACE_GENERIC_P(as));
+
+	//auto handle_inner_plus = [&](rtx tmp) -> bool
+	//{
+	//	const bool ret = (REG_P(XEXP(tmp, 0))
+	//		&& flare32_regno_ok_for_index_p(tmp, strict_p)
+	//		&& CONSTANT_P(XEXP(tmp, 1)));
+	//	fprintf(stderr, "flare32_legitimate_address_p()::%s:  %i\n",
+	//		"handle_inner_plus", ret);
+	//	return ret;
+	//};
+
+	//if (GET_CODE(x) == PLUS)
+	//{
+	//	//handle_inner_plus(tmp);
+	//	fprintf(stderr, "flare32_legitimate_address_p():  %ld\n",
+	//		(GET_CODE(XEXP(x, 0)) == PLUS));
+	//}
+
+	//if ((GET_CODE(x) == PLUS)
+	//	&& REG_P(XEXP(x, 0))
+	//	&& flare32_regno_ok_for_base_p(XEXP(x, 0), strict_p))
+	if (GET_CODE(x) == PLUS)
+	{
+		// SImode, DImode
+		if (GET_MODE_SIZE(mode) >= UNITS_PER_WORD)
+		{
+			//auto tmp = XEXP(x, 1);
+
+			//
+			//if (REG_P(tmp) && flare32_regno_ok_for_index_p(tmp, strict_p))
+			//{
+			//	return true;
+			//}
+
+			//switch (GET_CODE(tmp))
+			//{
+			//case PLUS:
+			//	{
+			//		return handle_inner_plus(tmp);
+			//	}
+			//	break;
+
+			//case CONST_INT:
+			//case SYMBOL_REF:
+			//case LABEL_REF:
+			//	return true;
+			//	break;
+
+			//default:
+			//	return false;
+			//}
+
+			// plus(plus(reg, reg), immediate)
+			if (GET_CODE(XEXP(x, 0)) == PLUS)
+			{
+				auto reg_plus_reg = XEXP(x, 0);
+				auto base = XEXP(reg_plus_reg, 0);
+				auto index = XEXP(reg_plus_reg, 1);
+				return (REG_P(base)
+					&& flare32_regno_ok_for_base_p(base, strict_p)
+					&& REG_P(index)
+					&& flare32_regno_ok_for_index_p(index, strict_p)
+					&& CONSTANT_P(XEXP(x, 1)));
+			}
+
+			if (REG_P(XEXP(x, 0))
+				&& flare32_regno_ok_for_base_p(XEXP(x, 0), strict_p))
+			{
+				auto some_index = XEXP(x, 1);
+
+				if (REG_P(some_index)
+					&& flare32_regno_ok_for_index_p(some_index, strict_p))
+				{
+					return true;
+				}
+
+				if (CONSTANT_P(some_index))
+				{
+					return true;
+				}
+			}
+
+		}
+
+		// QImode, HImode
+		else // if (GET_MODE_SIZE(mode) < UNITS_PER_WORD)
+		{
+			return (REG_P(XEXP(x, 0))
+				&& flare32_regno_ok_for_base_p(XEXP(x, 0), strict_p)
+				&& REG_P(XEXP(x, 1))
+				&& flare32_regno_ok_for_index_p(XEXP(x, 1), strict_p));
+		}
+	}
+	// All simple integer modes support this.
+	if (REG_P(x) && flare32_regno_ok_for_base_p(x, strict_p))
+	{
+		return true;
+	}
+
+
+	//// Might need this later...
+	//if (GET_CODE(x) == SYMBOL_REF
+	//	|| GET_CODE(x) == LABEL_REF
+	//	|| GET_CODE(x) == CONST)
+	//{
+	//	return true;
+	//}
+
+	return false;
+}
+
+static reg_class_t flare32_secondary_reload(bool in_p, rtx x,
+	reg_class_t reload_class_as_t, machine_mode reload_mode,
+	secondary_reload_info* sri)
+{
+	const reg_class reload_class = reg_class(reload_class_as_t);
+
+	const auto regno = true_regnum(x);
+
+	sri->icode = CODE_FOR_nothing;
+	sri->extra_cost = 0;
+
+	if (flare32_reg_class_cpyspec(reload_class)
+		|| (reload_class == HILO_REGS))
+	{
+		if ((regno != -1) && ((GET_CODE(x) == REG)
+			|| (GET_CODE(x) == SUBREG))
+			&& (REGNO_REG_CLASS(regno) == GENERAL_REGS))
+		{
+			return NO_REGS;
+		}
+
+		sri->extra_cost = 1;
+		return GENERAL_REGS;
+	}
+	//else if (((GET_CODE(x) == REG) || (GET_CODE(x) == SUBREG))
+	//	&& flare32_reg_class_cpyspec(REGNO_REG_CLASS(regno)))
+	//{
+	//	if (reload_class != GENERAL_REGS)
+	//	{
+	//		return GENERAL_REGS;
+	//	}
+	//	return NO_REGS;
+	//}
+	//if (((GET_CODE(x) == REG) || (GET_CODE(x) == SUBREG))
+	//	&& flare32_reg_class_cpyspec(REGNO_REG_CLASS(regno)))
+	//{
+	//}
+
+	return NO_REGS;
+}
+
+
+static bool flare32_fixed_condition_code_regs(unsigned int *p1,
+	unsigned int *p2)
+{
+	*p1 = FLARE32_FLAGS;
+	*p2 = INVALID_REGNUM;
+	return true;
+}
+
+//static reg_class_t flare32_target_spill_class(reg_class_t rc,
+//	machine_mode mode)
+//{
+//	return reg_class_t(GENERAL_REGS);
+//	//return NO_REGS;
+//}
+
+
+// The PRINT_OPERAND worker.
+
+static void flare32_print_operand(FILE *file, rtx x, int code)
+{
+	auto operand = x;
+
+	int rgoff = 0;
+	int the_regno = 0;
+	switch (code)
+	{
+	case 0:
+		// No code, print as usual
+		break;
+
+	case 'L':
+		// Higher of two registers, print one up
+		rgoff = 1;
+		break;
+
+	case 'R':
+	case 'H':
+		// Higher of a register pair, print normal
+		rgoff = 0;
+		break;
+
+	default:
+		LOSE_AND_RETURN ("invalid operand modifier letter", x);
+		break;
+	}
+
+	/* Print an operand as without a modifier letter.  */
+	switch (GET_CODE(operand))
+	{
+	case REG:
+		the_regno = REGNO(operand) + rgoff;
+		if (the_regno >= FIRST_PSEUDO_REGISTER)
+		{
+			internal_error("internal error: bad register: %d",
+				the_regno);
+		}
+		fprintf(file, "%s", reg_names[the_regno]);
+		break;
+
+	case MEM:
+		output_address(GET_MODE(XEXP(operand, 0)), XEXP(operand, 0));
+		break;
+
+	default:
+		// No need to handle all strange variants, let
+		// output_addr_const do it for us.
+		if (CONSTANT_P(operand))
+		{
+			fprintf(file, "#");
+			output_addr_const(file, operand);
+			return;
+		}
+
+		LOSE_AND_RETURN("unexpected operand", x);
+	}
+}
+
+static void flare32_print_operand_address(FILE* file, machine_mode mode,
+	rtx x)
+{
+	rtx left, right;
+	switch (GET_CODE(x))
+	{
+	case REG:
+		fprintf(file, "%s", reg_names[REGNO(x)]);
+		break;
+
+	case PLUS:
+		left = XEXP(x, 0);
+		right = XEXP(x, 1);
+
+		// plus(plus(reg, reg), immediate)
+		if (GET_CODE(left) == PLUS)
+		{
+			auto base = XEXP(left, 0);
+			auto index = XEXP(left, 1);
+			fprintf(file, "%s, %s, ", reg_names[REGNO(base)],
+				reg_names[REGNO(index)]);
+			if (CONST_INT_P(right))
+			{
+				fprintf(file, "#%ld", INTVAL(right));
+			}
+			else if (CONSTANT_P(right))
+			{
+				fprintf(file, "#");
+				output_addr_const(file, right);
+			}
+			else
+			{
+				gcc_unreachable();
+			}
+		}
+		else
+		{
+			fprintf(file, "%s, ", reg_names[REGNO(left)]);
+
+			if (GET_CODE(right) == REG)
+			{
+				fprintf(file, "%s", reg_names[REGNO(right)]);
+			}
+			else if (CONST_INT_P(right))
+			{
+				fprintf(file, "#%ld", INTVAL(right));
+			}
+			else if (CONSTANT_P(right))
+			{
+				fprintf(file, "#");
+				output_addr_const(file, right);
+			}
+			else
+			{
+				gcc_unreachable();
+			}
+		}
+
+		//switch (GET_CODE(right))
+		//{
+		//case CONST_INT:
+		//	fprintf(file, "%s, %ld", reg_names[REGNO(left)],
+		//		INTVAL(right));
+		//	break;
+
+
+		//case REG:
+		//	fprintf(file, "%s, %s", reg_names[REGNO(left)],
+		//		reg_names[REGNO(right)]);
+		//	break;
+
+		//case PLUS:
+		//	fprintf(file, "%s, %s + ", reg_names[REGNO(left)],
+		//		reg_names[REGNO(XEXP(right, 0))]);
+		//	if (CONST_INT_P(XEXP(right, 1)))
+		//	{
+		//		fprintf(file, "%ld", INTVAL(XEXP(right, 1)));
+		//	}
+		//	else if (CONSTANT_P(XEXP(right, 1)))
+		//	{
+		//		output_addr_const(file, XEXP(right, 1));
+		//	}
+		//	else
+		//	{
+		//		gcc_unreachable();
+		//	}
+		//	break;
+
+		//default:
+		//	if (CONSTANT_P(right))
+		//	{
+		//		fprintf(file, "%s, ", reg_names[REGNO(left)]);
+		//		output_addr_const(file, right);
+		//	}
+		//	else
+		//	{
+		//		gcc_unreachable();
+		//	}
+		//	break;
+		//}
+		break;
+
+	//case LABEL_REF:
+	//	fprintf(file, "<some_label_ref>");
+	//	break;
+
+	case LABEL_REF:
+	case SYMBOL_REF:
+	case CONST:
+		//fprintf(file, "<some_symbol_ref>");
+
+		fprintf(file, "#");
+		output_addr_const(file, x);
+		break;
+
+	//case CONST:
+	//	fprintf(file, "<some_const>");
+	//	break;
+
+	default:
+		gcc_unreachable();
+		break;
+	}
+}
+
+bool flare32_32_bit_offset_address_p(rtx x)
+{
+	// Inside the "MEM"
+	x = XEXP(x, 0);
+
+	switch (GET_CODE(x))
+	{
+	case PLUS:
+
+		//if (REG_P(XEXP(x, 0)) && (REG_P(XEXP(x, 1))
+		//	|| CONST_INT_P(XEXP(x, 1))))
+		if (REG_P(XEXP(x, 0)) && (REG_P(XEXP(x, 1))
+			|| CONSTANT_P(XEXP(x, 1))))
+		{
+			return true;
+		}
+
+		//if (REG_P(XEXP(x, 0)) && (GET_CODE(XEXP(x, 1)) == PLUS))
+		//{
+		//	auto tmp = XEXP(x, 1);
+
+		//	//if (REG_P(XEXP(tmp, 0)) && CONST_INT_P(XEXP(tmp, 1)))
+		//	if (REG_P(XEXP(tmp, 0)) && CONSTANT_P(XEXP(tmp, 1)))
+		//	{
+		//		return true;
+		//	}
+		//}
+
+		if (GET_CODE(XEXP(x, 0)) == PLUS)
+		{
+			auto reg_plus_reg = XEXP(x, 0);
+
+			return (REG_P(XEXP(reg_plus_reg, 0))
+				&& REG_P(XEXP(reg_plus_reg, 1))
+				&& CONSTANT_P(XEXP(x, 1)));
+		}
+
+
+		break;
+
+	//case SYMBOL_REF:
+	////case LABEL_REF:
+	//case CONST:
+	//	return true;
+	default:
+		break;
+	}
+
+	return false;
+}
+
+bool flare32_non_32_bit_offset_address_p(rtx x)
+{
+	// Inside the "MEM"
+	x = XEXP(x, 0);
+
+	if (REG_P(x))
+	{
+		return true;
+	}
+
+	if (GET_CODE(x) == PLUS)
+	{
+		// Register + register indexing is allowed for 8-bit and 16-bit
+		// loads and stores.
+		return (REG_P(XEXP(x, 0)) && REG_P(XEXP(x, 1)));
+	}
+	
+	return false;
+}
+
+//bool flare32_non_offset_address_p(rtx x)
+//{
+//}
+
+// Compute the size of the local area and the size to be adjusted by the
+// prologue and epilogue.
+
+
+// Implements the macro INITIAL_ELIMINATION_OFFSET, return the OFFSET.
+
+int flare32_initial_elimination_offset(int from, int to)
+{
+	int ret = 0;
+
+	//ret = 0;
+
+	if (((from) == FRAME_POINTER_REGNUM)
+		&& ((to) == HARD_FRAME_POINTER_REGNUM))
+	{
+		flare32_compute_frame();
+
+		// There's technically a "push fp", but the compiler perhaps
+		// doesn't need to really know about the "push fp".
+		// The hard frame pointer is ABOVE the callee-saved registers
+		// preservation area (actually points at the very first
+		// location in the callee-saved registers preservation area).
+
+		// (fake_fp - fp) == -(callee_saved_reg_size - UNITS_PER_WORD)
+		ret = -(cfun->machine->callee_saved_reg_size - UNITS_PER_WORD);
+	}
+	else if ((from) == ARG_POINTER_REGNUM
+		&& (to) == HARD_FRAME_POINTER_REGNUM)
+	{
+		// account for the "push fp"
+		// arguments start two addresses above the hard frame pointer
+
+		// (fake_ap - fp) == (UNITS_PER_WORD * 2) == 8;
+		ret = (UNITS_PER_WORD * 2);
+	}
+	//if (((from) == ARG_POINTER_REGNUM)
+	//	&& ((to) == FRAME_POINTER_REGNUM))
+	//{
+	//	ret = 0x00;
+	//}
+	//if ((((from) == FRAME_POINTER_REGNUM)
+	//	|| ((from) == ARG_POINTER_REGNUM)))
+	//{
+	//	//ret = 0x0;
+	//}
+	else
+	{
+		abort ();
+	}
+
+	return ret;
+}
+
+static bool flare32_return_in_memory(const_tree type,
+	const_tree fntype ATTRIBUTE_UNUSED)
+{
+	const HOST_WIDE_INT size = int_size_in_bytes(type);
+	return ((size == -1) || (size > (2 * UNITS_PER_WORD)));
+	//return ((size == -1) || (size > UNITS_PER_WORD));
+}
+
+static unsigned HOST_WIDE_INT flare32_size_of_type(machine_mode mode,
+	const_tree type)
+{
+	unsigned HOST_WIDE_INT size;
+
+	if (type)
+	{
+		//if (AGGREGATE_TYPE_P(type))
+		//{
+		//	return true;
+		//}
+		size = int_size_in_bytes(type);
+	}
+	else
+	{
+		size = GET_MODE_SIZE(mode);
+	}
+
+	return size;
+}
+
+static bool flare32_must_pass_in_stack(machine_mode mode,
+	const_tree type)
+{
+	if (type && AGGREGATE_TYPE_P(type))
+	{
+		return true;
+	}
+	return (flare32_size_of_type(mode, type) > (2 * UNITS_PER_WORD));
+	//return (flare32_size_of_type(mode, type) > UNITS_PER_WORD);
+}
+
+
+// Return non-zero if the function argument described by TYPE is to be
+// passed by reference.
+static bool flare32_pass_by_reference
+	(cumulative_args_t cum ATTRIBUTE_UNUSED, machine_mode mode,
+	const_tree type, bool named ATTRIBUTE_UNUSED)
+{
+	//unsigned HOST_WIDE_INT size;
+
+	//if (type)
+	//{
+	//	if (AGGREGATE_TYPE_P(type))
+	//	{
+	//		return true;
+	//	}
+	//	size = int_size_in_bytes(type);
+	//}
+	//else
+	//{
+	//	size = GET_MODE_SIZE(mode);
+	//}
+
+	////return (size > (4 * (FLARE32_LAST_REG_FUNC_ARG + 1)));
+	//return (size > UNITS_PER_WORD);
+
+	if (type && AGGREGATE_TYPE_P(type))
+	{
+		return true;
+	}
+	return (flare32_size_of_type(mode, type) > (2 * UNITS_PER_WORD));
+}
+
+static int flare32_arg_partial_bytes(cumulative_args_t cum_v,
+	machine_mode mode, tree type, bool named)
+{
+	return 0;
+}
+
+// Return the next register to be used to hold a function argument or
+// NULL_RTX if there's no more space.
+static rtx flare32_function_arg(cumulative_args_t cum_v,
+	machine_mode mode, const_tree type ATTRIBUTE_UNUSED,
+	bool named ATTRIBUTE_UNUSED)
+{
+	//if (!named)
+	//{
+	//	return NULL_RTX;
+	//}
+
+	CUMULATIVE_ARGS* cum = get_cumulative_args(cum_v);
+
+	if ((*cum) <= FLARE32_LAST_REG_FUNC_ARG)
+	{
+		const auto temp = (*cum);
+		//fprintf(stderr, "\nflare32_function_arg REG:  %d\n", temp);
+		return gen_rtx_REG(mode, temp);
+	}
+	else 
+	{
+		//fprintf(stderr, "\nflare32_function_arg NULL_RTX\n");
+		return NULL_RTX;
+	}
+}
+
+#define FLARE32_FUNCTION_ARG_SIZE(MODE, TYPE)	\
+	((MODE) != BLKmode ? GET_MODE_SIZE (MODE)	\
+	: (unsigned) int_size_in_bytes (TYPE))
+
+// This hook need not do anything if the argument in question was passed on
+// the stack.
+static void
+flare32_function_arg_advance(cumulative_args_t cum_v, machine_mode mode,
+	const_tree type, bool named ATTRIBUTE_UNUSED)
+{
+	CUMULATIVE_ARGS* cum = get_cumulative_args(cum_v);
+
+	*cum = ((*cum <= FLARE32_R5)
+		? *cum + ((3 + FLARE32_FUNCTION_ARG_SIZE(mode, type)) / 4)
+		: *cum);
+}
+
+//// This hook need not do anything if the argument in question was passed on
+//// the stack.
+//static void flare32_function_arg_advance(cumulative_args_t cum_v,
+//	machine_mode mode, const_tree type, bool named ATTRIBUTE_UNUSED)
+//{
+//	CUMULATIVE_ARGS* cum = get_cumulative_args(cum_v);
+//
+//	//*cum = ((*cum <= FLARE32_R5)
+//	//	? *cum + ((3 + FLARE32_FUNCTION_ARG_SIZE(mode, type)) / 4)
+//	//	: *cum);
+//	//fprintf(stderr, "flare32_function_arg_advance:  %d\n", *cum);
+//
+//	if ((*cum) <= FLARE32_LAST_REG_FUNC_ARG)
+//	{
+//		//*cum += (3 + FLARE32_FUNCTION_ARG_SIZE(mode, type)) / 4;
+//
+//		//// AFAIK we don't have any BLKmode instructions....
+//		//if (mode == BLKmode)
+//		//{
+//		//	abort();
+//		//}
+//
+//		const auto size = (mode != BLKmode) ? GET_MODE_SIZE(mode)
+//			: static_cast<unsigned>(int_size_in_bytes(type));
+//
+//		//fprintf(stderr, "flare32_function_arg_advance size:  %d\n", size);
+//
+//		// Small operands
+//		if ((size / 4) == 0)
+//		{
+//			*cum += 1;
+//		}
+//		else
+//		{
+//			*cum += size / 4;
+//		}
+//	}
+//	//else
+//	//{
+//	//	*cum = FLARE32_LAST_REG_FUNC_ARG + 1;
+//	//}
+//
+//	//fprintf(stderr, "flare32_function_arg_advance:  %d\n\n", *cum);
+//}
+
+bool flare32_absolute(rtx x)
+{
+	return ((GET_CODE(x) == SYMBOL_REF) || (GET_CODE(x) == LABEL_REF)
+		|| (GET_CODE(x) == CONST) || CONST_INT_P(x));
+}
+bool flare32_reg_cpyspec(rtx x)
+{
+	return (REG_P(x)
+		&& flare32_reg_class_cpyspec(REGNO_REG_CLASS(REGNO(x))));
+}
+bool flare32_reg_class_cpyspec(reg_class x)
+{
+	return ((x == CC_REGS) || (x == HI_REGS) || (x == LO_REGS));
+	//return ((x == HI_REGS) || (x == LO_REGS));
+}
+bool flare32_reg_general(rtx x)
+{
+	return (REG_P(x)
+		&& flare32_reg_class_general(REGNO_REG_CLASS(REGNO(x))));
+}
+bool flare32_reg_class_general(reg_class x)
+{
+	return (x == GENERAL_REGS);
+}
+
+
+
+
+// Zero initialization is OK for all current fields.
+static machine_function* flare32_init_machine_status()
+{
+	return ggc_cleared_alloc<machine_function>();
+}
+
+static bool flare32_target_rtx_costs(rtx x,
+	machine_mode mode, int outer_code ATTRIBUTE_UNUSED,
+	int opno ATTRIBUTE_UNUSED, int* total, bool speed)
+{
+	if (speed)
+	{
+		switch (GET_CODE(x))
+		{
+		case PLUS:
+		case MINUS:
+			if (mode == DImode)
+			{
+				*total = COSTS_N_INSNS(2);
+			}
+			break;
+		case MULT:
+			if (mode == SImode)
+			{
+				*total = COSTS_N_INSNS(4);
+			}
+			else if (mode == DImode)
+			{
+				*total = COSTS_N_INSNS(6);
+			}
+			break;
+
+		case DIV:
+		case UDIV:
+		case MOD:
+		case UMOD:
+			if (mode == SImode)
+			{
+				// Assume 4 bits computed per cycle.
+				*total = COSTS_N_INSNS(8);
+			}
+			else if (mode == DImode)
+			{
+				// Assume 2 bits computed per cycle.
+				*total = COSTS_N_INSNS(32);
+			}
+			break;
+
+		default:
+			break;
+		}
+	}
+	//else
+	//{
+	//}
+
+	return true;
+}
+
+static int flare32_target_memory_move_cost(machine_mode mode,
+	reg_class_t rclass_as_t, bool in)
+{
+	const reg_class rclass = reg_class(rclass_as_t);
+
+	int ret = 2;
+
+	if (rclass != GENERAL_REGS)
+	{
+		ret *= 2;
+	}
+
+
+	if (mode == DImode)
+	{
+		ret *= 2;
+	}
+	return ret;
+}
+
+static void flare32_option_override()
+{
+	// Set the per-function-data initializer.
+	init_machine_status = flare32_init_machine_status;
+}
+
+bool flare32_regno_actually_callee_saved(int regno)
+{
+	// Don't need to preserve "pc"
+	// Need to preserve "lr" if it gets used.
+	// "df_regs_ever_live_p" checks whether or not the register is
+	// used in this function.
+	//return ((regno != FLARE32_PC) && df_regs_ever_live_p(regno)
+	//	&& (regno != FLARE32_FAKE_FP) && (regno != FLARE32_FAKE_AP)
+	//	&& ((!call_used_regs[regno]) || (regno == FLARE32_LR)));
+	if (regno == FLARE32_PC)
+	{
+		return false;
+	}
+	if (df_regs_ever_live_p(regno))
+	//if (regs_ever_live(regno))
+	{
+		//if (regno == FLARE32_HI)
+		//{
+		//	fprintf(stderr, "\nflare32_regno_actually_callee_saved():  "
+		//		"what the heck!\n");
+		//}
+		if ((regno == FLARE32_FAKE_FP) && (regno == FLARE32_FAKE_AP))
+		{
+			return false;
+		}
+
+		if ((!call_used_regs[regno]) || (regno == FLARE32_LR))
+		{
+			return true;
+		}
+	}
+	return false;
+}
+
+//static bool flare32_use_lr()
+//{
+//	return df_regs_ever_live_p(FLARE32_LR);
+//}
+
+void flare32_compute_frame()
+{
+	auto& machine = *cfun->machine;
+
+	machine.update_stack_args_size();
+	machine.update_local_vars_size();
+	machine.update_callee_saved_reg_size();
+	machine.update_size_for_adjusting_sp();
+}
+
+void flare32_expand_prologue()
+{
+	rtx insn;
+
+	flare32_compute_frame();
+
+	auto& machine = *cfun->machine;
+	//fprintf(stderr, "flare32_expand_prologue():  %d %d %d\n",
+	//	crtl->args.pretend_args_size, machine.local_vars_size,
+	//	machine.stack_args_size);
+
+	if (flag_stack_usage_info)
+	{
+		current_function_static_stack_size
+			= machine.size_for_adjusting_sp;
+	}
+
+	auto gen_push = [&](int regno) -> void
+	{
+		insn = emit_insn(gen_movsi_push(gen_rtx_REG(SImode, regno)));
+		RTX_FRAME_RELATED_P(insn) = 1;
+	};
+
+	// Save the frame pointer
+	//if (df_regs_ever_live_p(FLARE32_FP))
+	//if ((machine.local_vars_size > 0)
+	//	|| (machine.stack_args_size > 0))
+	{
+		gen_push(FLARE32_FP);
+
+		// Set the frame pointer
+		insn = emit_insn(gen_movsi(hard_frame_pointer_rtx,
+			stack_pointer_rtx));
+		RTX_FRAME_RELATED_P(insn) = 1;
+	}
+
+	//fprintf(stderr, "\nflare32_expand_prologue()\n");
+
+	// Save callee-saved registers
+	for (int regno=0; regno<FIRST_PSEUDO_REGISTER; ++regno)
+	{
+		if (flare32_regno_actually_callee_saved(regno))
+		{
+			gen_push(regno);
+		}
+	}
+
+
+	// Adjust the stack pointer.
+	if (machine.size_for_adjusting_sp > 0)
+	{
+		insn = emit_insn(gen_subsi3(stack_pointer_rtx, stack_pointer_rtx,
+			GEN_INT(machine.size_for_adjusting_sp)));
+		RTX_FRAME_RELATED_P(insn) = 1;
+	}
+
+}
+void flare32_expand_epilogue()
+{
+	//int regno;
+	rtx insn;
+
+	auto gen_pop = [&](int regno) -> void
+	{
+		insn = emit_insn(gen_movsi_pop(gen_rtx_REG(SImode, regno)));
+		RTX_FRAME_RELATED_P(insn) = 1;
+	};
+
+	auto& machine = *cfun->machine;
+
+	if (machine.size_for_adjusting_sp > 0)
+	{
+		insn = emit_insn(gen_addsi3(stack_pointer_rtx, stack_pointer_rtx,
+			GEN_INT(machine.size_for_adjusting_sp)));
+		RTX_FRAME_RELATED_P(insn) = 1;
+	}
+
+	//fprintf(stderr, "\nflare32_expand_epilogue()\n");
+
+	// Restore callee-saved registers
+	for (int regno=FIRST_PSEUDO_REGISTER-1; regno>=0; --regno)
+	{
+		if (flare32_regno_actually_callee_saved(regno))
+		{
+			gen_pop(regno);
+		}
+	}
+
+	// Restore the frame pointer.
+	//if (df_regs_ever_live_p(FLARE32_FP))
+	//if ((machine.local_vars_size > 0)
+	//	|| (machine.stack_args_size > 0))
+	{
+		gen_pop(FLARE32_FP);
+	}
+
+
+	emit_jump_insn(gen_returner());
+}
+bool flare32_expand_movdi(rtx dst, rtx src)
+{
+	// cpy !REG, !REG 
+	if ((!REG_P(dst)) && (!REG_P(src)) && can_create_pseudo_p())
+	{
+		auto tmp = gen_reg_rtx(DImode);
+		emit_insn(gen_movdi_raw(tmp, src));
+		emit_insn(gen_movdi_raw(dst, tmp));
+		return true;
+	}
+
+	if (flare32_reg_cpyspec(dst)
+		&& ((!REG_P(src)) || (!flare32_reg_general(src)))
+		&& can_create_pseudo_p())
+	{
+		auto tmp = gen_reg_rtx(DImode);
+		emit_insn(gen_movdi_raw(tmp, src));
+		emit_insn(gen_movdi_raw(dst, tmp));
+		return true;
+	}
+
+	// cpy REG, REG
+	if (REG_P(dst) && REG_P(src))
+	{
+		emit_insn(gen_movdi_raw(dst, src));
+		return true;
+	}
+
+	// cpyi REG, immediate
+	if (REG_P(dst) && flare32_absolute(src))
+	{
+		emit_insn(gen_movdi_raw(dst, src));
+		return true;
+	}
+
+	if (MEM_P(dst) && (MEM_P(src) || CONST_INT_P(src))
+		&& can_create_pseudo_p())
+	{
+		rtx tmp;
+
+		if (MEM_P(src))
+		{
+			tmp = gen_reg_rtx(GET_MODE(src));
+		}
+		else if (CONST_INT_P(src))
+		{
+			tmp = gen_reg_rtx(DImode);
+		}
+		else
+		{
+			return false;
+		}
+
+		emit_insn(gen_movdi_raw(tmp, src));
+		emit_insn(gen_movdi_raw(dst, tmp));
+		return true;
+	}
+
+	if (MEM_P(dst) && can_create_pseudo_p()
+		&& flare32_absolute(XEXP(dst, 0)))
+	{
+		auto tmp = gen_reg_rtx(GET_MODE(dst));
+		emit_insn(gen_movdi_raw(tmp, XEXP(dst, 0)));
+		emit_insn(gen_movdi_raw(dst, tmp));
+		return true;
+	}
+
+	if (MEM_P(src) && can_create_pseudo_p()
+		&& flare32_absolute(XEXP(src, 0)))
+	{
+		auto tmp = gen_reg_rtx(GET_MODE(src));
+		emit_insn(gen_movdi_raw(tmp, XEXP(src, 0)));
+		emit_insn(gen_movdi_raw(src, tmp));
+		return true;
+	}
+
+	return false;
+	//return true;
+}
+
+// Initialize the GCC target structure.
+
+//#undef TARGET_PROMOTE_PROTOTYPES
+//#define TARGET_PROMOTE_PROTOTYPES hook_bool_const_tree_true
+
+#undef TARGET_PROMOTE_FUNCTION_MODE
+#define TARGET_PROMOTE_FUNCTION_MODE \
+	default_promote_function_mode_always_promote
+
+#undef TARGET_RETURN_IN_MEMORY
+#define TARGET_RETURN_IN_MEMORY flare32_return_in_memory
+#undef TARGET_MUST_PASS_IN_STACK
+//#define TARGET_MUST_PASS_IN_STACK must_pass_in_stack_var_size
+#define TARGET_MUST_PASS_IN_STACK flare32_must_pass_in_stack
+//#undef  TARGET_PASS_BY_REFERENCE
+//#define TARGET_PASS_BY_REFERENCE flare32_pass_by_reference
+//#undef  TARGET_ARG_PARTIAL_BYTES
+//#define TARGET_ARG_PARTIAL_BYTES flare32_arg_partial_bytes
+//#define TARGET_ARG_PARTIAL_BYTES hook_bool_void_false
+#undef TARGET_FUNCTION_ARG
+#define TARGET_FUNCTION_ARG flare32_function_arg
+#undef  TARGET_FUNCTION_ARG_ADVANCE
+#define TARGET_FUNCTION_ARG_ADVANCE flare32_function_arg_advance
+
+#undef TARGET_LRA_P
+#define TARGET_LRA_P hook_bool_void_false
+//#define TARGET_LRA_P hook_bool_void_true
+
+#undef  TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P
+#define TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P flare32_legitimate_address_p
+
+//#undef  TARGET_SETUP_INCOMING_VARARGS
+//#define TARGET_SETUP_INCOMING_VARARGS flare32_setup_incoming_varargs
+
+#undef TARGET_SECONDARY_RELOAD
+#define TARGET_SECONDARY_RELOAD flare32_secondary_reload
+
+#undef TARGET_FIXED_CONDITION_CODE_REGS
+#define TARGET_FIXED_CONDITION_CODE_REGS flare32_fixed_condition_code_regs
+
+//#define TARGET_SPILL_CLASS flare32_target_spill_class
+
+// Define this to return an RTX representing the place where a
+// function returns or receives a value of data type RET_TYPE, a tree
+// node representing a data type.
+#undef TARGET_FUNCTION_VALUE
+#define TARGET_FUNCTION_VALUE flare32_function_value
+#undef TARGET_LIBCALL_VALUE
+#define TARGET_LIBCALL_VALUE flare32_libcall_value
+#undef TARGET_FUNCTION_VALUE_REGNO_P
+#define TARGET_FUNCTION_VALUE_REGNO_P flare32_function_value_regno_p
+
+#undef TARGET_FRAME_POINTER_REQUIRED
+#define TARGET_FRAME_POINTER_REQUIRED hook_bool_void_true
+//#define TARGET_FRAME_POINTER_REQUIRED hook_bool_void_false
+
+//#undef TARGET_STATIC_CHAIN
+//#define TARGET_STATIC_CHAIN flare32_static_chain
+//#undef TARGET_ASM_TRAMPOLINE_TEMPLATE
+//#define TARGET_ASM_TRAMPOLINE_TEMPLATE flare32_asm_trampoline_template
+//#undef TARGET_TRAMPOLINE_INIT
+//#define TARGET_TRAMPOLINE_INIT flare32_trampoline_init
+
+
+#undef TARGET_RTX_COSTS
+#define TARGET_RTX_COSTS flare32_target_rtx_costs
+
+#undef TARGET_MEMORY_MOVE_COST
+#define TARGET_MEMORY_MOVE_COST flare32_target_memory_move_cost
+
+#undef TARGET_OPTION_OVERRIDE
+#define TARGET_OPTION_OVERRIDE flare32_option_override
+
+#undef  TARGET_PRINT_OPERAND
+#define TARGET_PRINT_OPERAND flare32_print_operand
+#undef  TARGET_PRINT_OPERAND_ADDRESS
+#define TARGET_PRINT_OPERAND_ADDRESS flare32_print_operand_address
+
+#undef  TARGET_CONSTANT_ALIGNMENT
+#define TARGET_CONSTANT_ALIGNMENT constant_alignment_word_strings
+
+
+
+
+
+
+
+struct gcc_target targetm = TARGET_INITIALIZER;
+
+//#include "gt-flare32.h"
diff -x build-x86_64-pc-linux-gnu -x host-x86_64-pc-linux-gnu -x config.log -x config.status -x flare32-elf -x '*.taghl' -x tags -x Makefile -Nur gcc-8.2.0/gcc/config/flare32/flare32.c gcc-8.2.0-flare32/gcc/config/flare32/flare32.c
--- gcc-8.2.0/gcc/config/flare32/flare32.c	1969-12-31 19:00:00.000000000 -0500
+++ gcc-8.2.0-flare32/gcc/config/flare32/flare32.c	2018-11-30 13:20:32.267595000 -0500
@@ -0,0 +1 @@
+#include "flare32_actual.hpp"
diff -x build-x86_64-pc-linux-gnu -x host-x86_64-pc-linux-gnu -x config.log -x config.status -x flare32-elf -x '*.taghl' -x tags -x Makefile -Nur gcc-8.2.0/gcc/config/flare32/flare32.h gcc-8.2.0-flare32/gcc/config/flare32/flare32.h
--- gcc-8.2.0/gcc/config/flare32/flare32.h	1969-12-31 19:00:00.000000000 -0500
+++ gcc-8.2.0-flare32/gcc/config/flare32/flare32.h	2018-12-07 13:22:34.665897827 -0500
@@ -0,0 +1,596 @@
+#ifndef GCC_FLARE32_H
+#define GCC_FLARE32_H
+
+/*
+#undef  STARTFILE_SPEC
+#define STARTFILE_SPEC "%{!mno-crt0:crt0%O%s} crti.o%s crtbegin.o%s"
+
+// Provide an ENDFILE_SPEC appropriate for svr4.  Here we tack on our own
+// magical crtend.o file (see crtstuff.c) which provides part of the
+// support for getting C++ file-scope static object constructed before
+// entering `main', followed by the normal svr3/svr4 "finalizer" file,
+// which is either `gcrtn.o' or `crtn.o'.
+
+#undef ENDFILE_SPEC
+#define ENDFILE_SPEC "crtend.o%s crtn.o%s"
+
+// Provide a LIB_SPEC appropriate for svr4.  Here we tack on the default
+// standard C library (unless we are building a shared library) and
+// the simulator BSP code.
+
+#undef LIB_SPEC
+#define LIB_SPEC "%{!shared:%{!symbolic:-lc}}"
+
+#undef LINK_SPEC
+#define LINK_SPEC "%{h*} %{v:-V} %{!mel:-EB} %{mel:-EL}\
+		%{static:-Bstatic} %{shared:-shared} %{symbolic:-Bsymbolic}"
+
+#ifndef MULTILIB_DEFAULTS
+#define MULTILIB_DEFAULTS { "meb" }
+#endif
+*/
+
+
+
+#define BITS_BIG_ENDIAN 0
+#define BYTES_BIG_ENDIAN 1
+#define WORDS_BIG_ENDIAN 1
+//#define REG_WORDS_BIG_ENDIAN
+
+#define UNITS_PER_WORD 4
+
+// Layout of Source Language Data Types
+#define INT_TYPE_SIZE 32
+#define SHORT_TYPE_SIZE 16
+#define LONG_TYPE_SIZE 32
+#define LONG_LONG_TYPE_SIZE 64
+#define CHAR_TYPE_SIZE 8
+
+#define DEFAULT_SIGNED_CHAR 0
+
+#undef SIZE_TYPE
+#define SIZE_TYPE "unsigned int"
+
+#undef PTRDIFF_TYPE
+#define PTRDIFF_TYPE "int"
+
+#undef WCHAR_TYPE
+#define WCHAR_TYPE "unsigned int"
+
+#undef  WCHAR_TYPE_SIZE
+#define WCHAR_TYPE_SIZE BITS_PER_WORD
+
+// Registers
+#define REGISTER_NAMES \
+	{ \
+		"r0", "r1", "r2", "r3", \
+		"r4", "r5", "r6", "r7", \
+		"r8", "r9", "r10", "r11", \
+		"r12", "lr", "fp", "sp", \
+		"fake_fp", "fake_ap", \
+		"hi", "lo", "flags", "pc" \
+	}
+
+#define FLARE32_R0 0
+#define FLARE32_R1 1
+#define FLARE32_R2 2
+#define FLARE32_R3 3
+#define FLARE32_R4 4
+#define FLARE32_R5 5
+#define FLARE32_R6 6
+#define FLARE32_R7 7
+#define FLARE32_R8 8
+#define FLARE32_R9 9
+#define FLARE32_R10 10
+#define FLARE32_R11 11
+#define FLARE32_R12 12
+#define FLARE32_LR 13
+#define FLARE32_FP 14
+#define FLARE32_SP 15
+#define FLARE32_FAKE_FP 16
+#define FLARE32_FAKE_AP 17
+#define FLARE32_HI 18
+#define FLARE32_LO 19
+#define FLARE32_FLAGS 20
+#define FLARE32_PC 21
+
+#define FLARE32_LAST_REG_FUNC_ARG FLARE32_R5
+
+#define FIRST_PSEUDO_REGISTER (FLARE32_PC + 1)
+
+// If the program counter has a register number, define this as that
+// register number.
+#define PC_REGNUM FLARE32_PC
+
+// Registers with fixed purposes marked with a "1"
+#define FIXED_REGISTERS \
+	{ \
+		0, 0, 0, 0, \
+		0, 0, 0, 0, \
+		0, 0, 0, 0, \
+		0, 0, 1, 1, \
+		1, 1, \
+		0, 0, 1, 1, \
+	}
+
+// Registers clobbered upon function call
+// "r0"-"r5" used for arguments
+// "r0" used for return value
+// "lr" clobbered upon function call
+// "flags" clobbered upon function call
+// "hi" and "lo" clobbered upon function call
+#define CALL_USED_REGISTERS \
+	{ \
+		1, 1, 1, 1, \
+		1, 1, 0, 0, \
+		0, 0, 0, 0, \
+		0, 1, 1, 1, \
+		1, 1, \
+		1, 1, 1, 1, \
+	}
+
+enum reg_class
+{
+	NO_REGS,
+	GENERAL_REGS,
+	SPECIAL_REGS,
+	CC_REGS,
+	HI_REGS,
+	LO_REGS,
+	HILO_REGS,
+	ALL_REGS,
+	LIM_REG_CLASSES,
+};
+
+#define N_REG_CLASSES LIM_REG_CLASSES
+
+#define REG_CLASS_NAMES \
+	{ \
+		"NO_REGS", \
+		"GENERAL_REGS", \
+		"SPECIAL_REGS", \
+		"CC_REGS", \
+		"HI_REGS", \
+		"LO_REGS", \
+		"HILO_REGS", \
+		"ALL_REGS", \
+	}
+
+
+// NO_REGS:  Empty
+// GENERAL_REGS:  r0 to r12, lr, fp, sp, fake_fp, fake_ap
+// SPECIAL_REGS:  pc
+// CC_REGS:  flags
+// HI_REGS:  hi
+// LO_REGS:  lo
+
+#define REG_CLASS_CONTENTS \
+	{ \
+		{0x0}, \
+		{0x3ffff}, \
+		{0x200000}, \
+		{0x100000}, \
+		{0x40000}, \
+		{0x80000}, \
+		\
+		/* HILO_REGS:  hi, lo */ \
+		{(1 << FLARE32_HI) | (1 << FLARE32_LO)}, \
+		\
+		/* ALL_REGS:  All registers */ \
+		{0x3fffff}, \
+	}
+
+
+const enum reg_class flare32_regno_to_class[FIRST_PSEUDO_REGISTER]
+	= {
+		// r0, r1, r2, r3
+		GENERAL_REGS, GENERAL_REGS, GENERAL_REGS, GENERAL_REGS,
+
+		// r4, r5, r6, r7
+		GENERAL_REGS, GENERAL_REGS, GENERAL_REGS, GENERAL_REGS,
+
+		// r8, r9, r10, r11
+		GENERAL_REGS, GENERAL_REGS, GENERAL_REGS, GENERAL_REGS,
+
+		// r12, lr, fp, sp
+		GENERAL_REGS, GENERAL_REGS, GENERAL_REGS, GENERAL_REGS,
+
+		// fake_fp, fake_ap
+		GENERAL_REGS, GENERAL_REGS,
+
+		// hi, lo, flags, pc
+		HI_REGS, LO_REGS, CC_REGS, SPECIAL_REGS,
+	};
+
+/*
+#define REG_ALLOC_ORDER \
+	{FLARE32_HI, FLARE32_LO, \
+	FLARE32_R0, FLARE32_R1, FLARE32_R2, FLARE32_R3, \
+	FLARE32_R4, FLARE32_R5, FLARE32_R6, FLARE32_R7, \
+	FLARE32_R8, FLARE32_R9, FLARE32_R10, FLARE32_R11, \
+	FLARE32_R12, FLARE32_LR, FLARE32_FP, FLARE32_SP}
+*/
+
+// A C expression whose value is a register class containing hard register
+// REGNO.
+#define REGNO_REG_CLASS(R) ((R < FIRST_PSEUDO_REGISTER) \
+	? flare32_regno_to_class[R] : SPECIAL_REGS)
+
+
+// Force GCC to accept that FLARE32_LR is to be restored during the
+// epilogue
+#define EPILOGUE_USES(r) (r == FLARE32_LR)
+
+// Don't add this until adding in DWARF2 stuff
+//#define INCOMING_RETURN_ADDR_RTX gen_rtx_REG(Pmode, FLARE32_LR)
+
+
+
+//// A C expression that is nonzero if it is permissible to store a
+//// value of mode MODE in hard register number REGNO (or in several
+//// registers starting with that one).
+//#define HARD_REGNO_MODE_OK(REGNO, MODE) 1
+
+
+/*
+// Define this macro if it is advisable to hold scalars in registers
+// in a wider mode than that declared by the program.  In such cases,
+// the value is constrained to be within the bounds of the declared
+// type, but kept valid in the wider mode.  The signedness of the
+// extension may differ from that of the type.
+
+#define PROMOTE_MODE(MODE, UNSIGNEDP, TYPE) \
+	do \
+	{ \
+		if ((GET_MODE_CLASS(MODE) == MODE_INT) \
+			&& (GET_MODE_SIZE(MODE) < 4)) \
+		{ \
+			(MODE) = SImode; \
+		} \
+	} while(0)
+*/
+
+//// Define this macro if the compiler should avoid copies to/from CCmode
+//// registers. You should only define this macro if support for copying
+//// to/from CCmode is incomplete.
+//// (Change this later as it *is* possible to back up/restore the flags)
+//#define AVOID_CCMODE_COPIES 1
+
+
+
+
+
+// The Overall Framework of an Assembler File
+#undef ASM_SPEC
+#define ASM_COMMENT_START ";"
+#define ASM_APP_ON ""
+#define ASM_APP_OFF ""
+
+
+// Switch to the text or data segment.
+#define TEXT_SECTION_ASM_OP  "\t.text"
+#define DATA_SECTION_ASM_OP  "\t.data"
+
+// Assembler Commands for Alignment
+
+#define ASM_OUTPUT_ALIGN(STREAM,POWER) \
+	fprintf (STREAM, "\t.p2align\t%d\n", POWER);
+
+// Output and Generation of Labels
+
+#define GLOBAL_ASM_OP "\t.global\t"
+
+
+
+
+// Passing Function Arguments
+
+//// A C expression. If nonzero, push insns will be used to pass outgoing
+//// arguments. If the target machine does not have a push instruction, set
+//// it to zero.
+//#define PUSH_ARGS 0
+
+// A C type for declaring a variable that is used as the first
+// argument of `FUNCTION_ARG' and other related values.
+#define CUMULATIVE_ARGS unsigned int
+
+
+// A C expression. If nonzero, the maximum amount of space required for
+// outgoing arguments will be computed and placed into
+// crtl->outgoing_args_size. No space will be pushed onto the stack for
+// each call; instead, the function prologue should increase the stack
+// frame size by this amount.  Setting both PUSH_ARGS and
+// ACCUMULATE_OUTGOING_ARGS is not proper.
+#define ACCUMULATE_OUTGOING_ARGS 1
+
+//// Define this if it is the responsibility of the caller to allocate
+//// the area reserved for arguments passed in registers.
+//#define REG_PARM_STACK_SPACE(FNDECL) (6 * UNITS_PER_WORD)
+
+// A C statement (sans semicolon) for initializing the variable CUM
+// for the state at the beginning of the argument list.
+// For flare32, the first arg is passed in register 0 (aka r0).
+#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME,FNDECL,N_NAMED_ARGS) \
+	(CUM = FLARE32_R0)
+
+
+// How Scalar Function Values Are Returned
+
+// STACK AND CALLING
+
+// Stack frame setup:
+// High
+//						------------------------
+// old sp, fake_ap		on-stack parameter area
+//						------------------------
+//						old fp
+//						------------------------
+// fp					register save area
+//						------------------------
+//						local variable save area
+//						------------------------
+//						padding for alignment
+//						------------------------
+// sp					right after frame
+// Low
+
+// Define this macro if pushing a word onto the stack moves the stack
+// pointer to a smaller address.
+#define STACK_GROWS_DOWNWARD 1
+
+// Define this macro to nonzero value if the addresses of local variable
+// slots are at negative offsets from the frame pointer.
+#define FRAME_GROWS_DOWNWARD 1
+
+
+// Offset from the argument pointer register to the first argument’s
+// address.  If ARGS_GROW_DOWNWARD, this is the offset to the location
+// above the first argument’s address.
+//#define FIRST_PARM_OFFSET(fundecl) UNITS_PER_WORD
+#define FIRST_PARM_OFFSET(fundecl) 0
+
+
+//// If defined, a C expression whose value is an integer giving the offset
+//// in bytes from the frame pointer to the canonical frame address (cfa).
+//// The final value should coincide with that calculated by
+//// INCOMING_FRAME_SP_OFFSET.  Normally the CFA is calculated as an offset
+//// from the argument pointer, via ARG_POINTER_CFA_OFFSET, but if the
+//// argument pointer is variable due to the ABI, this may not be possible.
+//// If this macro is defined, it implies that the virtual register
+//// instantiation should be based on the frame pointer instead of the
+//// argument pointer.  Only one of FRAME_POINTER_CFA_OFFSET and
+//// ARG_POINTER_CFA_OFFSET should be defined.
+//#define FRAME_POINTER_CFA_OFFSET(funcdecl) UNITS_PER_WORD
+
+//#define ARGS_GROW_DOWNWARD 1
+
+
+// This macro defines the operation used when something is pushed on the
+// stack.  In RTL, a push operation will be
+// (set (mem (STACK_PUSH_CODE (reg sp))) ....)
+#define STACK_PUSH_CODE POST_DEC
+
+
+
+// Registers That Address the Stack Frame
+
+
+// The register number of the stack pointer register, which must also
+// be a fixed register according to `FIXED_REGISTERS'.
+#define STACK_POINTER_REGNUM FLARE32_SP
+
+// The register number of the frame pointer register, which is used to
+// access automatic variables in the stack frame.
+#define FRAME_POINTER_REGNUM FLARE32_FAKE_FP
+//#define FRAME_POINTER_REGNUM FLARE32_FP
+
+// The register number of the arg pointer register, which is used to
+// access the function's argument list.
+#define ARG_POINTER_REGNUM FLARE32_FAKE_AP
+//#define ARG_POINTER_REGNUM FLARE32_FP
+
+#define HARD_FRAME_POINTER_REGNUM FLARE32_FP
+
+
+
+
+
+// Addressing modes
+
+// Specify the machine mode that pointers have.
+// After generation of rtl, the compiler makes no further distinction
+// between pointers and any other objects of this machine mode.
+#define Pmode SImode
+
+
+
+// A macro whose definition is the name of the class to which a
+// valid base register must belong.  A base register is one used in
+// an address which is the register value plus a displacement.
+#define BASE_REG_CLASS GENERAL_REGS
+
+
+
+// A macro whose definition is the name of the class to which a
+// valid index register must belong.  An index register is one used
+// in an address where its value is either multiplied by a scale
+// factor or added to another register (as well as added to a
+// displacement).
+#define INDEX_REG_CLASS BASE_REG_CLASS
+
+
+// An alias for the machine mode used for memory references to
+// functions being called, in `call' RTL expressions.
+#define FUNCTION_MODE HImode
+
+
+
+#define ELIMINABLE_REGS \
+	{{FRAME_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM}, \
+	{ARG_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM}}
+
+/*
+#define ELIMINABLE_REGS \
+	{{ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM}}
+*/
+
+// This macro returns the initial difference between the specified pair
+// of registers.
+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET) \
+	do \
+	{ \
+		(OFFSET) = flare32_initial_elimination_offset((FROM), (TO)); \
+	} while (0)
+
+// A C expression that is nonzero if REGNO is the number of a hard
+// register in which function arguments are sometimes passed.
+#define FUNCTION_ARG_REGNO_P(r) ((r >= FLARE32_R0) \
+	&& (r <= FLARE32_LAST_REG_FUNC_ARG))
+
+
+#define HARD_REGNO_OK_FOR_BASE_P(NUM) \
+	((unsigned) (NUM) < FIRST_PSEUDO_REGISTER \
+	&& (REGNO_REG_CLASS(NUM) == GENERAL_REGS))
+#define HARD_REGNO_OK_FOR_INDEX_P(NUM) \
+	((unsigned) (NUM) < FIRST_PSEUDO_REGISTER \
+	&& (REGNO_REG_CLASS(NUM) == GENERAL_REGS))
+
+
+
+
+
+#ifdef REG_OK_STRICT
+// A C expression which is nonzero if register number NUM is suitable
+// for use as a base register in operand addresses.
+#define REGNO_OK_FOR_BASE_P(NUM)   \
+	(HARD_REGNO_OK_FOR_BASE_P(NUM)    \
+	|| HARD_REGNO_OK_FOR_BASE_P(reg_renumber[(NUM)]))
+
+// A C expression which is nonzero if register number NUM is suitable
+// for use as an index register in operand addresses.
+// We don't have index registers.
+#define REGNO_OK_FOR_INDEX_P(NUM)   \
+	(HARD_REGNO_OK_FOR_INDEX_P(NUM)    \
+	|| HARD_REGNO_OK_FOR_INDEX_P(reg_renumber[(NUM)]))
+#else
+// A C expression which is nonzero if register number NUM is suitable
+// for use as a base register in operand addresses.
+#define REGNO_OK_FOR_BASE_P(NUM)   \
+	((NUM) >= FIRST_PSEUDO_REGISTER || HARD_REGNO_OK_FOR_BASE_P(NUM))
+
+// A C expression which is nonzero if register number NUM is suitable
+// for use as an index register in operand addresses.
+// We don't have index registers.
+#define REGNO_OK_FOR_INDEX_P(NUM)   \
+	((NUM) >= FIRST_PSEUDO_REGISTER || HARD_REGNO_OK_FOR_INDEX_P(NUM))
+#endif
+
+//#define REGNO_OK_FOR_INDEX_P(NUM) 0
+
+// The maximum number of bytes that a single instruction can move
+// quickly between memory and registers or between two memory
+// locations.
+#define MOVE_MAX UNITS_PER_WORD
+
+// Not all loads zero extend, but other backends that have both zero extend
+// and sign extend loads do this.
+#define LOAD_EXTEND_OP(MEM) ZERO_EXTEND
+
+// Short immediates definitely do sign extend.
+#define SHORT_IMMEDIATES_SIGN_EXTEND 1
+
+// A number, the maximum number of registers that can appear in a
+// valid memory address.
+// Registers are 32-bit, and addresses are also 32-bit.
+#define MAX_REGS_PER_ADDRESS 2
+
+// An alias for a machine mode name.  This is the machine mode that
+// elements of a jump-table should have.
+#define CASE_VECTOR_MODE HImode
+
+
+// Describing Relative Costs of Operations
+// Define this macro as a C expression which is nonzero if accessing
+// less than a word of memory (i.e. a `char' or a `short') is no
+// faster than accessing a word of memory.
+#define SLOW_BYTE_ACCESS 1
+
+// It's generally better to use an immediate-encoded function address for
+// calls than to keep the function address in a register.
+// Most function calls can be done with "bl" and, in practice, they can
+// probably be done with 18-bit branch offsets.
+#define NO_FUNCTION_CSE true
+
+
+
+// Trampoline schtick
+#define TRAMPOLINE_SIZE 1
+
+#define TARGET_CPU_CPP_BUILTINS() \
+	{ \
+		builtin_define_std ("flare32"); \
+		builtin_define_std ("FLARE32"); \
+		builtin_define ("__FLARE32__"); \
+	}
+
+//#undef TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P
+//#define TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P flare32_legitimate_address_p
+
+
+
+// Normal alignment required for function parameters on the stack, in bits.
+// All stack parameters receive at least this much alignment regardless of
+// data type. On most machines, this is the same as the size of an integer.
+#define PARM_BOUNDARY 32
+
+// Define this macro to the minimum alignment enforced by hardware for the
+// stack pointer on this machine. The definition is a C expression for the
+// desired alignment (measured in bits). This value is used as a default if
+// PREFERRED_STACK_BOUNDARY is not defined. On most machines, this should
+// be the same as PARM_BOUNDARY.
+#define STACK_BOUNDARY 32
+
+// Alignment required for a function entry point, in bits.
+#define FUNCTION_BOUNDARY 16
+
+// Biggest alignment that any data type can require on this machine, in
+// bits.  Note that this is not the biggest alignment that is supported,
+// just the biggest alignment that, when violated, may cause a fault.
+#define BIGGEST_ALIGNMENT 32
+
+#define FASTEST_ALIGNMENT 32
+
+
+// Set this nonzero if move instructions will actually fail to work
+// when given unaligned data.
+#define STRICT_ALIGNMENT 1
+
+
+// Alignment of field after `int : 0' in a structure.
+#define EMPTY_FIELD_BOUNDARY  32
+
+// Look at the fundamental type that is used for a bit-field and use 
+// that to impose alignment on the enclosing structure.
+// struct s {int a:8}; should have same alignment as "int", not "char".
+#define PCC_BITFIELD_TYPE_MATTERS 1
+
+// Largest integer machine mode for structures.  If undefined, the default
+// is GET_MODE_SIZE(DImode).
+#define MAX_FIXED_MODE_SIZE 32
+
+// Make arrays of chars word-aligned for the same reasons.
+#define DATA_ALIGNMENT(TYPE, ALIGN)		\
+	(TREE_CODE (TYPE) == ARRAY_TYPE		\
+	&& TYPE_MODE (TREE_TYPE (TYPE)) == QImode	\
+	&& (ALIGN) < FASTEST_ALIGNMENT ? FASTEST_ALIGNMENT : (ALIGN))
+     
+// Generating Code for Profiling
+#define FUNCTION_PROFILER(FILE,LABELNO) (abort (), 0)
+
+#define HAS_LONG_COND_BRANCH true
+#define HAS_LONG_UNCOND_BRANCH true
+
+#define TARGET_OBJECT_SUFFIX ".o"
+
+
+#endif		// GCC_FLARE32_H
diff -x build-x86_64-pc-linux-gnu -x host-x86_64-pc-linux-gnu -x config.log -x config.status -x flare32-elf -x '*.taghl' -x tags -x Makefile -Nur gcc-8.2.0/gcc/config/flare32/flare32.md gcc-8.2.0-flare32/gcc/config/flare32/flare32.md
--- gcc-8.2.0/gcc/config/flare32/flare32.md	1969-12-31 19:00:00.000000000 -0500
+++ gcc-8.2.0-flare32/gcc/config/flare32/flare32.md	2018-12-07 13:23:02.148978290 -0500
@@ -0,0 +1,1135 @@
+;; Machine description for Flare32
+
+;;(include "../../gcc/config/flare32/constraints.md")
+;;(include "../../gcc/config/flare32/predicates.md")
+
+;; Registers by name
+(define_constants
+	[(REG_LR 13)
+	(REG_FP 14)
+	(REG_SP 15)
+	(REG_LO 18)
+	(REG_HI 19)
+	(REG_FLAGS 20)
+	(REG_PC 21)])
+
+;; Predicate definitions for Flare32
+
+
+;; ---------------
+;; Predicates
+;; ---------------
+
+;;(define_predicate "flare32_hi_reg"
+;;	(match_code "reg,subreg")
+;;{
+;;	return (REG_P(op) && (REGNO_REG_CLASS(REGNO(op)) == HI_REGS));
+;;})
+;;
+;;(define_predicate "flare32_lo_reg"
+;;	(match_code "reg,subreg")
+;;{
+;;	return (REG_P(op) && (REGNO_REG_CLASS(REGNO(op)) == LO_REGS));
+;;})
+
+
+;;(define_predicate "flare32_general_movsrc_operand"
+;;	(match_code "mem,const_int,reg,subreg,symbol_ref,label_ref,const")
+;;{
+;;	if (MEM_P(op) && ((GET_CODE(XEXP(op, 0)) == LABEL_REF)
+;;		|| (GET_CODE(XEXP(op, 0)) == SYMBOL_REF)
+;;		|| (GET_CODE(XEXP(op, 0)) == CONST)))
+;;	{
+;;		return false;
+;;	}
+;;	if ((GET_CODE(op) == LABEL_REF)
+;;		|| (GET_CODE(op) == SYMBOL_REF)
+;;		|| (GET_CODE(op) == CONST))
+;;	{
+;;		return 1;
+;;	}
+;;
+;;	static const int MIN_SIMM18 = -131072;
+;;	static const int MAX_SIMM18 = 131071;
+;;
+;;	//// Non-indexed load
+;;	//if (MEM_P(op)
+;;	//	&& (GET_CODE(XEXP(op, 0)) == REG))
+;;	//{
+;;	//	return 1;
+;;	//}
+;;
+;;	// Indexed load
+;;	if (MEM_P(op)
+;;		&& (GET_CODE(XEXP(op, 0)) == PLUS)
+;;		&& (GET_CODE(XEXP(XEXP(op, 0), 0)) == REG)
+;;		&& (GET_CODE(XEXP(XEXP(op, 0), 1)) == CONST_INT)
+;;		&& (IN_RANGE(INTVAL(XEXP(XEXP(op, 0), 1)), MIN_SIMM18,
+;;		MAX_SIMM18)))
+;;	{
+;;		return 1;
+;;	}
+;;
+;;	return general_operand(op, mode);
+;;})
+
+
+
+;; ---------------
+;; Constraints
+;; ---------------
+
+
+
+
+;;(define_register_constraint "r" "GENERAL_REGS"
+;;	"A general purpose register")
+(define_register_constraint "f" "CC_REGS" "flags")
+(define_register_constraint "h" "HI_REGS" "hi")
+(define_register_constraint "l" "LO_REGS" "lo")
+(define_register_constraint "k" "HILO_REGS" "hi OR lo")
+;;(define_register_constraint "u" "GENERAL_DIMODE_REGS" "regular regs")
+(define_constraint "d" "pc"
+	(and (match_code "reg")
+		(match_test "(REGNO(op) == FLARE32_PC)")))
+(define_constraint "t" "sp"
+	(and (match_code "reg")
+		(match_test "(REGNO(op) == FLARE32_SP)")))
+(define_constraint "q" "fp"
+	(and (match_code "reg")
+		(match_test "(REGNO(op) == FLARE32_FP)")))
+(define_constraint "S" "cpyspec"
+	(and (match_code "reg")
+		(match_test "(REGNO_REG_CLASS(REGNO(op)) == CC_REGS)
+			|| (REGNO_REG_CLASS(REGNO(op)) == HI_REGS)
+			|| (REGNO_REG_CLASS(REGNO(op)) == LO_REGS)")))
+;;(define_constraint "S" "cpyspec"
+;;	(and (match_code "reg")
+;;		(match_test "(REGNO_REG_CLASS(REGNO(op)) == HI_REGS)
+;;			|| (REGNO_REG_CLASS(REGNO(op)) == LO_REGS)")))
+
+;;(define_constraint "A"
+;;	"An absolute address as memory reference."
+;;	(and (match_code "mem")
+;;		(ior (match_test "GET_CODE(XEXP(op, 0)) == SYMBOL_REF")
+;;			(match_test "GET_CODE(XEXP(op, 0)) == LABEL_REF")
+;;			(match_test "GET_CODE(XEXP(op, 0)) == CONST"))))
+(define_constraint "A"
+	"An absolute address as memory reference."
+	(and (match_code "mem")
+		(match_test "flare32_absolute(op)")))
+
+;;(define_constraint "Q"
+;;	"An absolute address."
+;;	(ior (match_test "GET_CODE(op) == SYMBOL_REF")
+;;		(match_test "GET_CODE(op) == LABEL_REF")
+;;		(match_test "GET_CODE(op) == CONST")))
+(define_constraint "Q"
+	"An absolute address."
+	(match_test "flare32_absolute(op)"))
+
+;;(define_constraint "I"
+;;	"An 18-bit signed immediate"
+;;	(and (match_code "const_int")
+;;		(match_test "(ival >= -131072) && (ival <= 131071)")))
+;;
+;;(define_constraint "J"
+;;	"The constant 16"
+;;	(and (match_code "const_int")
+;;		(match_test "(ival == 16)")))
+;;(define_constraint "J"
+;;	"A 32-bit immediate"
+;;	(and (match_code "const_int") (match_test
+;;	"((((unsigned)ival) >= 0x0) && (((unsigned)ival) <= 0xffffffff))")))
+
+(define_constraint "B"
+	"An offset address (immediate or NOT immediate)."
+	(and (match_code "mem")
+		(match_test "flare32_32_bit_offset_address_p(op)")))
+(define_constraint "C"
+	"An offset address (NOT immediate)."
+	(and (match_code "mem")
+		(match_test "flare32_non_32_bit_offset_address_p(op)")))
+
+
+(define_constraint "W"
+	"A register indirect memory operand."
+	(and (match_code "mem")
+		(match_test "REG_P(XEXP(op, 0))
+			&& REGNO_OK_FOR_BASE_P(REGNO(XEXP(op, 0)))")))
+
+
+;;(define_constraint "O"
+;;	"The constant zero"
+;;	(and (match_code "const_int")
+;;		(match_test "ival == 0")))
+
+
+
+;; Most instructions are two bytes long
+;;(define_attr "length" "" (const_int 2))
+
+(define_insn "nop"
+	[(const_int 0)]
+	"true"
+	"add r0, #0		; nop")
+
+;; -----------------------
+;; Arithmetic Instructions
+;; -----------------------
+
+
+(define_insn "addsi3"
+	[(set (match_operand:SI 0 "register_operand" "=r,r,r,r,r,r,r")
+		(plus:SI
+			(match_operand:SI 1 "register_operand" "0,t,q,0,d,t,q")
+			(match_operand:SI 2 "general_operand" "r,r,r,i,i,i,i")))]
+	""
+	"@
+	add %0, %2
+	add %0, %1, %2
+	add %0, %1, %2
+	add %0, %2
+	add %0, %1, %2
+	add %0, %1, %2
+	add %0, %1, %2");
+
+(define_insn "adddi3"
+	[(set (match_operand:DI 0 "register_operand" "=&r")
+		(plus:DI
+			(match_operand:DI 1 "register_operand" "%0")
+			(match_operand:DI 2 "register_operand" "r")))
+	(clobber (reg:CC REG_FLAGS))]
+	""
+	"add.f %L0, %L2\n\tadc.f %H0, %H2")
+
+;;(define_expand "adddi3"
+;;	[(parallel
+;;		[(set (match_operand:DI 0 "register_operand" "=&r")
+;;			(plus:DI
+;;				(match_operand:DI 1 "register_operand" "%0")
+;;				(match_operand:DI 2 "general_operand" "")))
+;;			(clobber (reg:CC REG_FLAGS))])]
+;;	""
+;;{
+;;	if (!REG_P(operands[2]))
+;;	{
+;;		operands[2] = force_reg(DImode, operands[2]);
+;;	}
+;;})
+;;
+;;(define_insn "*adddi3"
+;;	[(set (match_operand:DI 0 "register_operand" "=&r")
+;;		(plus:DI
+;;			(match_operand:DI 1 "register_operand" "%0")
+;;			(match_operand:DI 2 "register_operand" "r")))
+;;		(clobber (reg:CC REG_FLAGS))]
+;;	""
+;;	"fake_add64 %0, %2")
+
+(define_insn "subsi3"
+	[(set (match_operand:SI 0 "register_operand" "=r,r,r,r,r")
+		(minus:SI
+			(match_operand:SI 1 "register_operand" "0,0,d,t,q")
+			(match_operand:SI 2 "general_operand" "r,i,i,i,i")))]
+	""
+	"@
+	sub %0, %2
+	add %0, -%2
+	add %0, %1, -%2
+	add %0, %1, -%2
+	add %0, %1, -%2");
+
+
+(define_insn "subdi3"
+	[(set (match_operand:DI 0 "register_operand" "=&r")
+		(minus:DI
+			(match_operand:DI 1 "register_operand" "%0")
+			(match_operand:DI 2 "register_operand" "r")))
+	(clobber (reg:CC REG_FLAGS))]
+	""
+	"sub.f %L0, %L2\n\tsbc.f %H0, %H2")
+
+
+(define_insn "mulsi3"
+	[(set (match_operand:SI 0 "register_operand" "=r")
+		(mult:SI
+			(match_operand:SI 1 "register_operand" "0")
+			(match_operand:SI 2 "register_operand" "r")))]
+	""
+	"mul %0, %2")
+
+(define_insn "umulsidi3"
+	[(set (match_operand:DI 0 "register_operand" "=k")
+		(mult:DI
+			(zero_extend:DI (match_operand:SI 1 "register_operand" "r"))
+			(zero_extend:DI (match_operand:SI 2 "register_operand"
+				"r"))))]
+	""
+	"lumul %1, %2")
+(define_insn "mulsidi3"
+	[(set (match_operand:DI 0 "register_operand" "=k")
+		(mult:DI
+			(sign_extend:DI (match_operand:SI 1 "register_operand" "r"))
+			(sign_extend:DI (match_operand:SI 2 "register_operand"
+				"r"))))]
+	""
+	"lsmul %1, %2")
+
+(define_insn "udivsi3"
+	[(set (match_operand:SI 0 "register_operand" "=r")
+		(udiv:SI
+			(match_operand:SI 1 "register_operand" "0")
+			(match_operand:SI 2 "register_operand" "r")))]
+	""
+	"udiv %0, %2")
+
+(define_insn "divsi3"
+	[(set (match_operand:SI 0 "register_operand" "=r")
+		(div:SI
+			(match_operand:SI 1 "register_operand" "0")
+			(match_operand:SI 2 "register_operand" "r")))]
+	""
+	"sdiv %0, %2")
+
+(define_insn "umodsi3"
+	[(set (match_operand:SI 0 "register_operand" "=r")
+		(umod:SI
+			(match_operand:SI 1 "register_operand" "0")
+			(match_operand:SI 2 "register_operand" "r")))]
+	""
+	"umod %0, %2")
+
+(define_insn "modsi3"
+	[(set (match_operand:SI 0 "register_operand" "=r")
+		(mod:SI
+			(match_operand:SI 1 "register_operand" "0")
+			(match_operand:SI 2 "register_operand" "r")))]
+	""
+	"smod %0, %2")
+
+(define_insn "udivdi3"
+	[(set (match_operand:DI 0 "register_operand" "=k")
+		(udiv:DI
+			(match_operand:DI 1 "register_operand" "0")
+			(match_operand:DI 2 "register_operand" "r")))]
+	""
+	"ludiv %H2, %L2")
+
+(define_insn "divdi3"
+	[(set (match_operand:DI 0 "register_operand" "=k")
+		(div:DI
+			(match_operand:DI 1 "register_operand" "0")
+			(match_operand:DI 2 "register_operand" "r")))]
+	""
+	"lsdiv %H2, %L2")
+(define_insn "umoddi3"
+	[(set (match_operand:DI 0 "register_operand" "=k")
+		(umod:DI
+			(match_operand:DI 1 "register_operand" "0")
+			(match_operand:DI 2 "register_operand" "r")))]
+	""
+	"lumod %H2, %L2")
+
+(define_insn "moddi3"
+	[(set (match_operand:DI 0 "register_operand" "=k")
+		(mod:DI
+			(match_operand:DI 1 "register_operand" "0")
+			(match_operand:DI 2 "register_operand" "r")))]
+	""
+	"lsmod %H2, %L2")
+
+;;(define_insn "mulsi3"
+;;	[(set (match_operand:SI 0 "register_operand" "=l")
+;;		(mult:SI
+;;			(match_operand:SI 1 "register_operand" "h")
+;;			(match_operand:SI 2 "register_operand" "l")))
+;;		(clobber (match_operand:SI 3 "register_operand" ""))]
+;;	""
+;;{
+;;	//if (REGNO_REG_CLASS(REGNO(operands[1])) != HI_REGS)
+;;	//{
+;;	//	auto hi = gen_rtx_REG(SImode, REG_HI);
+;;	//	emit_insn(gen_movsi(operands[3], hi));
+;;
+;;	//}
+;;
+;;	//else
+;;	//{
+;;	//	return "lumul";
+;;	//}
+;;	emit_insn(gen_movsi(operands[3], operands[1]));
+;;	return "lumul\ncpyspec hi, %3";
+;;})
+
+
+(define_insn "ashlsi3"
+	[(set (match_operand:SI 0 "register_operand" "=r,r")
+	(ashift:SI (match_operand:SI 1 "register_operand" "0,0")
+	(match_operand:SI 2 "general_operand" "r,i")))]
+	""
+	"@
+	lsl %0, %2
+	lsl %0, %2")
+
+(define_insn "lshrsi3"
+	[(set (match_operand:SI 0 "register_operand" "=r,r")
+		(lshiftrt:SI (match_operand:SI 1 "register_operand" "0,0")
+			(match_operand:SI 2 "general_operand" "r,i")))]
+	""
+	"@
+	lsr %0, %2
+	lsr %0, %2")
+
+(define_insn "ashrsi3"
+	[(set (match_operand:SI 0 "register_operand" "=r,r")
+		(ashiftrt:SI (match_operand:SI 1 "register_operand" "0,0")
+			(match_operand:SI 2 "general_operand" "r,i")))]
+	""
+	"@
+	asr %0, %2
+	asr %0, %2")
+
+
+(define_insn "andsi3"
+	[(set (match_operand:SI 0 "register_operand" "=r,r")
+		(and:SI (match_operand:SI 1 "register_operand" "0,0")
+			(match_operand:SI 2 "general_operand" "r,i")))]
+	""
+	"@
+	and %0, %2
+	and %0, %2")
+
+(define_insn "iorsi3"
+	[(set (match_operand:SI 0 "register_operand" "=r,r")
+		(ior:SI (match_operand:SI 1 "register_operand" "0,0")
+			(match_operand:SI 2 "general_operand" "r,i")))]
+	""
+	"@
+	orr %0, %2
+	orr %0, %2")
+
+(define_insn "xorsi3"
+	[(set (match_operand:SI 0 "register_operand" "=r,r")
+		(xor:SI (match_operand:SI 1 "register_operand" "0,0")
+			(match_operand:SI 2 "general_operand" "r,i")))]
+	""
+	"@
+	xor %0, %2
+	xor %0, %2")
+
+(define_expand "one_cmplsi2"
+	[(set (match_operand:SI 0 "register_operand" "=r")
+		(not:SI (match_operand:SI 1 "register_operand" "0")))]
+	""
+{
+	auto tmp_const = GEN_INT(-1);
+	emit_insn(gen_xorsi3(operands[0], operands[0], tmp_const));
+	DONE;
+})
+
+
+
+(define_expand "movsi"
+	[(set (match_operand:SI 0 "nonimmediate_operand" "")
+		(match_operand:SI 1 "general_operand" ""))]
+	""
+
+{
+	if (MEM_P(operands[0]) && (MEM_P(operands[1])
+		|| CONST_INT_P(operands[1])))
+	{
+		if (can_create_pseudo_p())
+		{
+			rtx tmp;
+			
+			if (MEM_P(operands[1]))
+			{
+				tmp = gen_reg_rtx(GET_MODE(operands[1]));
+			}
+			else if (CONST_INT_P(operands[1]))
+			{
+				tmp = gen_reg_rtx(SImode);
+			}
+			else
+			{
+				//fprintf(stderr, "\nTest\n");
+				//abort();
+				FAIL;
+			}
+
+			emit_insn(gen_movsi(tmp, operands[1]));
+			operands[1] = tmp;
+		}
+	}
+	//else if (MEM_P(operands[0]) && flare32_absolute(operands[0]))
+	else if (MEM_P(operands[0]))
+	{
+		if (can_create_pseudo_p())
+		{
+			if (flare32_absolute(XEXP(operands[0], 0)))
+			{
+				auto tmp = gen_reg_rtx(GET_MODE(operands[0]));
+				emit_insn(gen_movsi(tmp, XEXP(operands[0], 0)));
+				operands[0] = tmp;
+			}
+
+			//if (flare32_reg_cpyspec(operands[1]))
+			//{
+			//	auto tmp = gen_reg_rtx(GET_MODE(operands[1]));
+			//	emit_insn(gen_movsi(tmp, operands[1]));
+			//	operands[1] = tmp;
+			//}
+		}
+	}
+	//else if (MEM_P(operands[1]) && flare32_absolute(operands[1]))
+	else if (MEM_P(operands[1]))
+	{
+		if (can_create_pseudo_p())
+		{
+			if (flare32_absolute(XEXP(operands[1], 0)))
+			{
+				auto tmp = gen_reg_rtx(GET_MODE(operands[1]));
+				emit_insn(gen_movsi(tmp, XEXP(operands[1], 0)));
+				operands[1] = tmp;
+			}
+			//if (flare32_reg_cpyspec(operands[0]))
+			//{
+			//	auto tmp = gen_reg_rtx(GET_MODE(operands[0]));
+			//	emit_insn(gen_movsi(tmp, operands[0]));
+			//	operands[0] = tmp;
+			//}
+		}
+	}
+
+	// cpy specreg, #immediate
+	// cpy specreg, other_specreg
+	else if (flare32_reg_cpyspec(operands[0]))
+	{
+		if ((!REG_P(operands[1])) || flare32_reg_cpyspec(operands[1]))
+		{
+			if (can_create_pseudo_p())
+			{
+				auto tmp = gen_reg_rtx(GET_MODE(operands[1]));
+				emit_insn(gen_movsi(tmp, operands[1]));
+				operands[1] = tmp;
+			}
+		}
+	}
+
+})
+
+
+(define_insn "*movsi"
+	[(set (match_operand:SI 0 "nonimmediate_operand"
+		"=r,r,r,r,r,B,W,r,A,r,S,S,r")
+		(match_operand:SI 1 "general_operand"
+		"r,i,Q,B,W,r,r,A,r,S,r,i,d"))]
+
+	;;"register_operand(operands[0], SImode)
+	;;|| register_operand(operands[1], SImode)"
+	""
+{
+	switch (which_alternative)
+	{
+	// "=r", "r"
+	case 0:
+		return "cpy %0, %1		; *movsi";
+		break;
+
+	// "=r", "i"
+	case 1:
+		return "cpy %0, %1		; =r, i";
+		break;
+
+	// "=r", "Q"
+	case 2:
+		return "cpy %0, %1		; =r, Q";
+		break;
+
+	// "=r", "B"
+	case 3:
+		return "ldr %0, [%1]		; =r, B";
+		break;
+
+	// "=r", "W"
+	case 4:
+		return "ldr %0, [%1, #0]		; =r, W";
+		break;
+
+	// "=B", "r"
+	case 5:
+		return "str %1, [%0]		; =B, r";
+		break;
+
+	// "=W", "r"
+	case 6:
+		return "str %1, [%0, #0]		; =W, r";
+		break;
+
+	// "=r", "A"
+	case 7:
+		return "ldr %0, [%1, #0]		; =r, A";
+		break;
+
+	// "=A", "r"
+	case 8:
+		return "str %1, [%0, #0]		; =A, r";
+		break;
+
+	// "=r", "S"
+	case 9:
+		return "cpy %0, %1";
+		break;
+
+	// "=S", "r"
+	case 10:
+		return "cpy %0, %1";
+		break;
+
+	// "=S", "i"
+	case 11:
+		return "11 eek!";
+		break;
+
+	// "=r", "d"
+	case 12:
+		return "add %0, pc, 0";
+		break;
+
+
+	default:
+		fprintf(stderr, "expand movsi Eek!  %d\n",
+			which_alternative);
+		abort();
+		//FAIL;
+		break;
+	}
+})
+
+
+;; Push a register onto the stack
+(define_insn "movsi_push"
+	[(set (mem:SI (post_dec:SI (reg:SI REG_SP)))
+		(match_operand:SI 0 "register_operand" "r,S"))]
+	""
+	"@
+	push %0
+	push %0		; cpyspec")
+
+;; Pop a register from the stack
+(define_insn "movsi_pop"
+	[(set (match_operand:SI 0 "register_operand" "=r,S")
+		(mem:SI (pre_inc:SI (reg:SI REG_SP))))]
+	""
+	"@
+	pop %0
+	pop %0		; cpyspec")
+
+(define_expand "movdi"
+	[(set (match_operand:DI 0 "nonimmediate_operand" "")
+		(match_operand:DI 1 "general_operand" ""))]
+	""
+
+{
+	//if (flare32_expand_movdi(operands[0], operands[1]))
+	//{
+	//	DONE;
+	//}
+	//FAIL;
+	flare32_expand_movdi(operands[0], operands[1]);
+})
+
+(define_insn "movdi_raw"
+	[(set (match_operand:DI 0 "nonimmediate_operand" "=r,r,r,k,r,r,B,W")
+		(match_operand:DI 1 "general_operand" "r,i,k,r,B,W,r,r"))]
+	""
+
+{
+	switch (which_alternative)
+	{
+	case 0:
+		return "cpy %L0, %L1\n\tcpy %H0, %H1"
+			"\t\t; movdi_raw";
+	case 1:
+		return "cpy %L0, #(%1 >> 32)\n\tcpy %H0, #(%1 & 0xffffffff)"
+			"\t\t; movdi_raw";
+	case 2:
+		return "cpy %L0, %L1\n\tcpy %H0, %H1"
+			"\t\t; movdi_raw";
+	case 3:
+		return "cpy %L0, %L1\n\tcpy %H0, %H1"
+			"\t\t; movdi_raw";
+	case 4:
+		return "ldr %L0, [%L1, #4]\n\tldr %H0, [%H1, #0] "
+			"\t\t; movdi_raw  =r, B";
+	case 5:
+		return "ldr %L0, [%L1, #4]\n\tldr %H0, [%H1, #0] "
+			"\t\t; movdi_raw  =r, W";
+	case 6:
+		return "str %L1, [%L0, #4]\n\tstr %H1, [%H0, #0] "
+			"\t\t; movdi_raw  =r, B";
+	case 7:
+		return "str %L1, [%L0, 4]\n\tstr %H1, [%H0, #0] "
+			"\t\t; movdi_raw  =r, W";
+	default:
+		fprintf(stderr, "movdi Eek!");
+		abort();
+	}
+})
+
+
+(define_expand "movhi"
+	[(set (match_operand:HI 0 "nonimmediate_operand" "")
+		(match_operand:HI 1 "general_operand" ""))]
+
+	""
+{
+	if (MEM_P(operands[0]) && (MEM_P(operands[1])
+		|| CONST_INT_P(operands[1])))
+	{
+		if (can_create_pseudo_p())
+		{
+			rtx tmp;
+			
+			if (MEM_P(operands[1]))
+			{
+				tmp = gen_reg_rtx(GET_MODE(operands[1]));
+			}
+			else if (CONST_INT_P(operands[1]))
+			{
+				tmp = gen_reg_rtx(HImode);
+			}
+			else
+			{
+				//abort();
+				FAIL;
+			}
+
+			emit_insn(gen_movhi(tmp, operands[1]));
+			operands[1] = tmp;
+		}
+	}
+	else if (MEM_P(operands[0]))
+	{
+		if (can_create_pseudo_p())
+		{
+			if (flare32_absolute(XEXP(operands[0], 0)))
+			{
+				auto tmp = gen_reg_rtx(GET_MODE(operands[0]));
+				emit_insn(gen_movhi(tmp, XEXP(operands[0], 0)));
+				operands[0] = tmp;
+			}
+		}
+	}
+	else if (MEM_P(operands[1]))
+	{
+		if (can_create_pseudo_p())
+		{
+			if (flare32_absolute(XEXP(operands[1], 0)))
+			{
+				auto tmp = gen_reg_rtx(GET_MODE(operands[1]));
+				emit_insn(gen_movhi(tmp, XEXP(operands[1], 0)));
+				operands[1] = tmp;
+			}
+		}
+	}
+
+	// cpy specreg, #immediate
+	// cpy specreg, other_specreg
+	else if (flare32_reg_cpyspec(operands[0]))
+	{
+		if ((!REG_P(operands[1])) || flare32_reg_cpyspec(operands[1]))
+		{
+			if (can_create_pseudo_p())
+			{
+				auto tmp = gen_reg_rtx(GET_MODE(operands[1]));
+				emit_insn(gen_movhi(tmp, operands[1]));
+				operands[1] = tmp;
+			}
+		}
+	}
+
+})
+
+(define_insn "*movhi"
+	[(set (match_operand:HI 0 "nonimmediate_operand"
+		"=r,r,r,r,r,C,W,r,A,r,S,S")
+		(match_operand:HI 1 "general_operand"
+		"r,i,Q,C,W,r,r,A,r,S,r,i"))]
+
+	"register_operand(operands[0], HImode)
+	|| register_operand(operands[1], HImode)"
+	;;""
+{
+	switch (which_alternative)
+	{
+	// "=r", "r"
+	case 0:
+		return "cpy %0, %1		; *movhi";
+
+	// "=r", "i"
+	case 1:
+		return "cpy %0, %1		; *movhi";
+
+	// "=r", "Q"
+	case 2:
+		return "cpy %0, %1		; *movhi";
+
+	// "=r", "C"
+	case 3:
+		return "lduh %0, [%1]		; =r, C";
+
+	// "=r", "W"
+	case 4:
+		return "lduh %0, [%1]		; =r, W";
+		break;
+
+	// "=C", "r"
+	case 5:
+		return "sth %1, [%0]		; =C, r";
+
+	// "=W", "r"
+	case 6:
+		return "sth %1, [%0]		; =W, r";
+
+	// "=r", "A"
+	case 7:
+		return "lduh %0, [%1]		; =r, A";
+
+	// "=A", "r"
+	case 8:
+		return "sth %1, [%0]		; =A, r";
+
+	// "=r", "S"
+	case 9:
+		return "cpyspec %0, %1		; *movhi";
+
+	// "=S", "r"
+	case 10:
+		return "cpyspec %0, %1		; *movhi";
+
+	// "=S", "i"
+	case 11:
+		return "9 eek!		; *movhi";
+
+	default:
+		fprintf(stderr, "expand movhi Eek!  %d\n",
+			which_alternative);
+		abort();
+		//FAIL;
+		break;
+	}
+})
+
+(define_expand "movqi"
+	[(set (match_operand:QI 0 "nonimmediate_operand" "")
+		(match_operand:QI 1 "general_operand" ""))]
+
+	""
+{
+	if (MEM_P(operands[0]) && (MEM_P(operands[1])
+		|| CONST_INT_P(operands[1])))
+	{
+		if (can_create_pseudo_p())
+		{
+			rtx tmp;
+			
+			if (MEM_P(operands[1]))
+			{
+				tmp = gen_reg_rtx(GET_MODE(operands[1]));
+			}
+			else if (CONST_INT_P(operands[1]))
+			{
+				tmp = gen_reg_rtx(QImode);
+			}
+			else
+			{
+				//abort();
+				FAIL;
+			}
+
+			emit_insn(gen_movqi(tmp, operands[1]));
+			operands[1] = tmp;
+		}
+	}
+	else if (MEM_P(operands[0]))
+	{
+		if (can_create_pseudo_p())
+		{
+			if (flare32_absolute(XEXP(operands[0], 0)))
+			{
+				auto tmp = gen_reg_rtx(GET_MODE(operands[0]));
+				emit_insn(gen_movqi(tmp, XEXP(operands[0], 0)));
+				operands[0] = tmp;
+			}
+		}
+	}
+	else if (MEM_P(operands[1]))
+	{
+		if (can_create_pseudo_p())
+		{
+			if (flare32_absolute(XEXP(operands[1], 0)))
+			{
+				auto tmp = gen_reg_rtx(GET_MODE(operands[1]));
+				emit_insn(gen_movqi(tmp, XEXP(operands[1], 0)));
+				operands[1] = tmp;
+			}
+		}
+	}
+
+	// cpy specreg, #immediate
+	// cpy specreg, other_specreg
+	else if (flare32_reg_cpyspec(operands[0]))
+	{
+		if ((!REG_P(operands[1])) || flare32_reg_cpyspec(operands[1]))
+		{
+			if (can_create_pseudo_p())
+			{
+				auto tmp = gen_reg_rtx(GET_MODE(operands[1]));
+				emit_insn(gen_movqi(tmp, operands[1]));
+				operands[1] = tmp;
+			}
+		}
+	}
+
+})
+
+(define_insn "*movqi"
+	[(set (match_operand:QI 0 "nonimmediate_operand"
+		"=r,r,r,r,r,C,W,r,A,r,S,S")
+		(match_operand:QI 1 "general_operand"
+		"r,i,Q,C,W,r,r,A,r,S,r,i"))]
+
+	"register_operand(operands[0], QImode)
+	|| register_operand(operands[1], QImode)"
+	;;""
+{
+	switch (which_alternative)
+	{
+	// "=r", "r"
+	case 0:
+		return "cpy %0, %1		; *movqi";
+
+	// "=r", "i"
+	case 1:
+		return "cpy %0, %1		; *movqi";
+
+	// "=r", "Q"
+	case 2:
+		return "cpy %0, %1		; *movqi";
+
+	// "=r", "C"
+	case 3:
+		return "ldub %0, [%1]		; =r, C";
+
+	// "=r", "W"
+	case 4:
+		return "ldub %0, [%1]		; =r, W";
+		break;
+
+	// "=C", "r"
+	case 5:
+		return "stb %1, [%0]		; =C, r";
+
+	// "=W", "r"
+	case 6:
+		return "stb %1, [%0]		; =W, r";
+
+	// "=r", "A"
+	case 7:
+		return "ldub %0, [%1]		; =r, A";
+
+	// "=A", "r"
+	case 8:
+		return "stb %1, [%0]		; =A, r";
+
+	// "=r", "S"
+	case 9:
+		return "cpyspec %0, %1		; *movqi";
+
+	// "=S", "r"
+	case 10:
+		return "cpyspec %0, %1		; *movqi";
+
+	// "=S", "i"
+	case 11:
+		return "9 eek!		; *movqi";
+
+	default:
+		fprintf(stderr, "expand movqi Eek!  %d\n",
+			which_alternative);
+		abort();
+		//FAIL;
+		break;
+	}
+})
+
+
+(define_insn "zero_extendhisi2"
+	[(set (match_operand:SI 0 "register_operand" "=r,r,r")
+		(zero_extend:SI (match_operand:HI 1 "nonimmediate_operand"
+			"0,C,W")))]
+	""
+	"@
+	zeh %0
+	lduh %0, [%1]		; zero_extendhisi2
+	lduh %0, [%1]		; zero_extendhisi2")
+
+(define_insn "extendhisi2"
+	[(set (match_operand:SI 0 "register_operand" "=r,r,r")
+		(sign_extend:SI (match_operand:HI 1 "nonimmediate_operand"
+			"0,C,W")))]
+	""
+	"@
+	seh %0
+	ldsh %0, [%1]		; sign_extendhisi2
+	ldsh %0, [%1]		; sign_extendhisi2")
+
+
+(define_insn "zero_extendqisi2"
+	[(set (match_operand:SI 0 "register_operand" "=r,r,r")
+		(zero_extend:SI (match_operand:QI 1 "nonimmediate_operand"
+			"0,C,W")))]
+	""
+	"@
+	zeb %0
+	ldub %0, [%1]		; zero_extendqisi2
+	ldub %0, [%1]		; zero_extendqisi2")
+
+(define_insn "sign_extendqisi2"
+	[(set (match_operand:SI 0 "register_operand" "=r,r,r")
+		(sign_extend:SI (match_operand:QI 1 "nonimmediate_operand"
+			"0,C,W")))]
+	""
+	"@
+	seb %0
+	ldsb %0, [%1]		; sign_extendqisi2
+	ldsb %0, [%1]		; sign_extendqisi2")
+
+
+
+
+(define_insn "cmpsi"
+	[(set (reg:CC REG_FLAGS)
+		(compare:CC (match_operand:SI 0 "register_operand" "r,r")
+			(match_operand:SI 1 "general_operand" "r,i")))]
+	""
+	"@
+	cmp %0, %1
+	cmp %0, %1")
+
+(define_expand "cbranchsi4"
+	[(set (reg:CC REG_FLAGS)
+		(compare:CC (match_operand:SI 1 "register_operand" "r,r")
+			(match_operand:SI 2 "nonmemory_operand" "r,i")))
+		(set (pc)
+			(if_then_else (match_operator 0 "comparison_operator"
+				[(reg:CC REG_FLAGS) (const_int 0)])
+				(label_ref (match_operand 3 "" ""))
+				(pc)))]
+	""
+{
+	// Force the things being compared into registers (or an immediate)
+	//if ((GET_CODE(operands[1]) != REG)
+	//	|| (REGNO_REG_CLASS(REGNO(operands[1])) != GENERAL_REGS))
+	//{
+	//	//operands[1] = force_reg(SImode, operands[1]);
+	//}
+	////if (GET_CODE(operands[2]) != REG)
+	////{
+	////	operands[2] = force_reg(SImode, operands[2]);
+	////}
+	//if ((GET_CODE(operands[2]) != REG)
+	//	|| (GET_CODE(operands[2]) != CONST_INT))
+	//{
+	//	operands[2] = force_reg(SImode, operands[2]);
+	//}
+})
+
+(define_code_iterator cond [ne eq geu ltu gtu leu ge lt gt le])
+(define_code_attr CC [(ne "ne") (eq "eq") (geu "geu") (ltu "ltu")
+	(gtu "gtu") (leu "leu") (ge "ges") (lt "lts") (gt "gts") (le "les")])
+
+(define_insn "b<cond:code>"
+	[(set (pc)
+		(if_then_else (cond (reg:CC REG_FLAGS) (const_int 0))
+			(label_ref (match_operand 0 "" ""))
+			(pc)))]
+	""
+	"b<CC> %l0")
+
+
+(define_insn "indirect_jump"
+	[(set (pc) (match_operand:SI 0 "nonimmediate_operand" "r"))]
+	""
+	"jmp %0")
+
+(define_insn "jump"
+	[(set (pc) (label_ref (match_operand 0 "" "")))]
+	""
+	"bra %l0")
+
+
+(define_expand "call"
+	[(parallel [(call (match_operand:HI 0 "memory_operand" "")
+		(match_operand 1 "general_operand" ""))
+		(clobber (reg:SI REG_LR))])]
+	""
+{
+	gcc_assert(MEM_P(operands[0]));
+})
+
+(define_insn "*call"
+	[(call (mem:HI (match_operand:SI 0 "nonmemory_operand" "i,r"))
+		(match_operand 1 "" ""))
+		(clobber (reg:SI REG_LR))]
+	""
+	"@
+	bl %0		; call
+	jl %0		; call")
+(define_expand "call_value"
+	[(parallel [(set (match_operand 0 "" "")
+		(call (match_operand:HI 1 "memory_operand" "")
+			(match_operand 2 "" "")))
+			(clobber (reg:SI REG_LR))])]
+	""
+{
+	gcc_assert(MEM_P(operands[1]));
+})
+
+
+(define_insn "*call_value"
+	[(set (match_operand 0 "register_operand" "=r,r")
+		(call (mem:HI (match_operand:SI 1 "nonmemory_operand" "i,r"))
+			(match_operand 2 "" "")))
+			(clobber (reg:SI REG_LR))]
+	""
+	"@
+	bl %1		; call_value
+	jl %1		; call_value")
+
+
+(define_expand "prologue"
+	[(clobber (const_int 0))]
+	""
+{
+	flare32_expand_prologue();
+	DONE;
+})
+
+;; --------------
+;; Epilogue
+;; --------------
+(define_expand "epilogue"
+	[(return)]
+	""
+{
+	flare32_expand_epilogue();
+	DONE;
+})
+
+(define_insn "returner"
+	[(return)]
+	"reload_completed"
+	"jmp lr")
diff -x build-x86_64-pc-linux-gnu -x host-x86_64-pc-linux-gnu -x config.log -x config.status -x flare32-elf -x '*.taghl' -x tags -x Makefile -Nur gcc-8.2.0/gcc/config/flare32/flare32-protos.h gcc-8.2.0-flare32/gcc/config/flare32/flare32-protos.h
--- gcc-8.2.0/gcc/config/flare32/flare32-protos.h	1969-12-31 19:00:00.000000000 -0500
+++ gcc-8.2.0-flare32/gcc/config/flare32/flare32-protos.h	2018-12-04 10:13:27.190583883 -0500
@@ -0,0 +1,21 @@
+
+extern int flare32_initial_elimination_offset(int from, int to);
+extern bool flare32_32_bit_offset_address_p(rtx x);
+extern bool flare32_non_32_bit_offset_address_p(rtx x);
+extern bool flare32_non_offset_address_p(rtx x);
+
+extern bool flare32_absolute(rtx x);
+
+extern bool flare32_reg_cpyspec(rtx x);
+extern bool flare32_reg_class_cpyspec(reg_class x);
+extern bool flare32_reg_general(rtx x);
+extern bool flare32_reg_class_general(reg_class x);
+
+
+extern bool flare32_regno_actually_callee_saved(int regno);
+extern void flare32_compute_frame();
+
+extern void flare32_expand_prologue();
+extern void flare32_expand_epilogue();
+
+extern bool flare32_expand_movdi(rtx dst, rtx src);
diff -x build-x86_64-pc-linux-gnu -x host-x86_64-pc-linux-gnu -x config.log -x config.status -x flare32-elf -x '*.taghl' -x tags -x Makefile -Nur gcc-8.2.0/gcc/config/flare32/t-flare32 gcc-8.2.0-flare32/gcc/config/flare32/t-flare32
--- gcc-8.2.0/gcc/config/flare32/t-flare32	1969-12-31 19:00:00.000000000 -0500
+++ gcc-8.2.0-flare32/gcc/config/flare32/t-flare32	2018-11-24 14:00:03.057678000 -0500
@@ -0,0 +1,25 @@
+## floating point emulation libraries
+#
+#FPBIT = fp-bit.c
+#DPBIT = dp-bit.c
+#
+#fp-bit.c: $(srcdir)/config/fp-bit.c
+#	echo '#define FLOAT'				> fp-bit.c
+#	cat $(srcdir)/config/fp-bit.c			>> fp-bit.c
+#
+#dp-bit.c: $(srcdir)/config/fp-bit.c
+#	cat $(srcdir)/config/fp-bit.c > dp-bit.c
+#
+## target-specific files
+#
+#md_file = md
+#
+##MD_FILES = constraints predicates flare32 
+#MD_FILES = flare32 
+#
+## Doing it this way lets the gen* programs report the right line numbers.
+#
+#md : $(MD_FILES:%=$(srcdir)/config/flare32/%.md) $(srcdir)/config/flare32/t-flare32
+#	for md in $(MD_FILES); do \
+#	  echo "(include \"$(srcdir)/config/flare32/$$md.md\")"; \
+#	done > md
diff -x build-x86_64-pc-linux-gnu -x host-x86_64-pc-linux-gnu -x config.log -x config.status -x flare32-elf -x '*.taghl' -x tags -x Makefile -Nur gcc-8.2.0/gcc/config.gcc gcc-8.2.0-flare32/gcc/config.gcc
--- gcc-8.2.0/gcc/config.gcc	2018-06-25 15:34:01.000000000 -0400
+++ gcc-8.2.0-flare32/gcc/config.gcc	2018-12-02 08:24:17.078666580 -0500
@@ -349,6 +349,9 @@
 ft32*)	cpu_type=ft32
 	target_has_targetm_common=no
 	;;
+flare32*)	cpu_type=flare32
+	target_has_targetm_common=no
+	;;
 moxie*)	cpu_type=moxie
 	target_has_targetm_common=no
 	;;
@@ -1305,6 +1308,12 @@
 	tm_file="dbxelf.h elfos.h newlib-stdint.h ${tm_file}"
 	tmake_file="${tmake_file} ft32/t-ft32"
 	;;
+flare32-*-elf)
+	gas=yes
+	gnu_ld=yes
+	tm_file="dbxelf.h elfos.h newlib-stdint.h ${tm_file}"
+	tmake_file="${tmake_file} flare32/t-flare32"
+	;;
 moxie-*-elf)
 	gas=yes
 	gnu_ld=yes
diff -x build-x86_64-pc-linux-gnu -x host-x86_64-pc-linux-gnu -x config.log -x config.status -x flare32-elf -x '*.taghl' -x tags -x Makefile -Nur gcc-8.2.0/libgcc/config.host gcc-8.2.0-flare32/libgcc/config.host
--- gcc-8.2.0/libgcc/config.host	2018-04-06 16:04:17.000000000 -0400
+++ gcc-8.2.0-flare32/libgcc/config.host	2018-12-07 13:57:55.670600925 -0500
@@ -115,6 +115,8 @@
 	;;
 ft32*)	cpu_type=ft32
 	;;
+flare32*)	cpu_type=flare32
+	;;
 moxie*)	cpu_type=moxie
 	;;
 i[34567]86-*-*)
@@ -966,6 +968,8 @@
 mn10300-*-*)
 	tmake_file=t-fdpbit
 	;;
+flare32-*-elf)
+	;;
 moxie-*-elf | moxie-*-moxiebox* | moxie-*-uclinux* | moxie-*-rtems*)
 	tmake_file="$tmake_file moxie/t-moxie t-softfp-sfdf t-softfp-excl t-softfp"
 	extra_parts="$extra_parts crti.o crtn.o crtbegin.o crtend.o"
diff -x build-x86_64-pc-linux-gnu -x host-x86_64-pc-linux-gnu -x config.log -x config.status -x flare32-elf -x '*.taghl' -x tags -x Makefile -Nur gcc-8.2.0/serdep.tmp gcc-8.2.0-flare32/serdep.tmp
--- gcc-8.2.0/serdep.tmp	1969-12-31 19:00:00.000000000 -0500
+++ gcc-8.2.0-flare32/serdep.tmp	2018-12-07 13:50:50.674511508 -0500
@@ -0,0 +1 @@
+# serdep.tmp
